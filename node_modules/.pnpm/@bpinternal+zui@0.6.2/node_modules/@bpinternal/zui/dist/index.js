var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/transforms/json-schema-to-zui/index.ts
import { parseSchema as parseSchema2 } from "@bpinternal/json-schema-to-zod";

// src/z/z.ts
var z_exports = {};
__export(z_exports, {
  BRAND: () => BRAND,
  DIRTY: () => DIRTY,
  EMPTY_PATH: () => EMPTY_PATH,
  INVALID: () => INVALID,
  NEVER: () => NEVER,
  OK: () => OK,
  ParseInputLazyPath: () => ParseInputLazyPath,
  ParseStatus: () => ParseStatus,
  Schema: () => ZodType,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBigInt: () => ZodBigInt,
  ZodBoolean: () => ZodBoolean,
  ZodBranded: () => ZodBranded,
  ZodCatch: () => ZodCatch,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodEffects: () => ZodEffects,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNever: () => ZodNever,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodParsedType: () => ZodParsedType,
  ZodPipeline: () => ZodPipeline,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRecord: () => ZodRecord,
  ZodSchema: () => ZodType,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodSymbol: () => ZodSymbol,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodTemplateLiteralUnsupportedCheckError: () => ZodTemplateLiteralUnsupportedCheckError,
  ZodTemplateLiteralUnsupportedTypeError: () => ZodTemplateLiteralUnsupportedTypeError,
  ZodTransformer: () => ZodEffects,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  addIssueToContext: () => addIssueToContext,
  any: () => anyType,
  array: () => arrayType,
  bigint: () => bigIntType,
  boolean: () => booleanType,
  coerce: () => coerce,
  createZodEnum: () => createZodEnum,
  cuid2Regex: () => cuid2Regex,
  cuidRegex: () => cuidRegex,
  custom: () => custom,
  date: () => dateType,
  datetimeRegex: () => datetimeRegex,
  defaultErrorMap: () => en_default,
  discriminatedUnion: () => discriminatedUnionType,
  effect: () => effectsType,
  emailRegex: () => emailRegex,
  enum: () => enumType,
  errorUtil: () => errorUtil,
  fromJsonSchema: () => fromJsonSchema,
  fromObject: () => fromObject,
  function: () => functionType,
  getErrorMap: () => getErrorMap,
  getParsedType: () => getParsedType,
  instanceof: () => instanceOfType,
  intersection: () => intersectionType,
  ipv4Regex: () => ipv4Regex,
  ipv6Regex: () => ipv6Regex,
  isAborted: () => isAborted,
  isAsync: () => isAsync,
  isDirty: () => isDirty,
  isValid: () => isValid,
  jsonSchemaToZui: () => jsonSchemaToZui,
  late: () => late,
  lazy: () => lazyType,
  literal: () => literalType,
  makeIssue: () => makeIssue,
  map: () => mapType,
  nan: () => nanType,
  nativeEnum: () => nativeEnumType,
  never: () => neverType,
  null: () => nullType,
  nullable: () => nullableType,
  number: () => numberType,
  object: () => objectType,
  objectToZui: () => objectToZui,
  objectUtil: () => objectUtil,
  oboolean: () => oboolean,
  onumber: () => onumber,
  optional: () => optionalType,
  ostring: () => ostring,
  pipeline: () => pipelineType,
  preprocess: () => preprocessType,
  processCreateParams: () => processCreateParams,
  promise: () => promiseType,
  quotelessJson: () => quotelessJson,
  record: () => recordType,
  set: () => setType,
  setErrorMap: () => setErrorMap,
  strictObject: () => strictObjectType,
  string: () => stringType,
  symbol: () => symbolType,
  templateLiteral: () => templateLiteralType,
  transformer: () => effectsType,
  tuple: () => tupleType,
  ulidRegex: () => ulidRegex,
  undefined: () => undefinedType,
  union: () => unionType,
  unknown: () => unknownType,
  util: () => util,
  uuidRegex: () => uuidRegex,
  void: () => voidType,
  zuiToJsonSchema: () => zuiToJsonSchema
});

// src/z/types/error/locales/en.ts
var errorMap = /* @__PURE__ */ __name((issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
}, "errorMap");
var en_default = errorMap;

// src/transforms/object-to-zui/index.ts
var dateTimeRegex = /^\d{4}-\d{2}-\d{2}(T|\s)?((\d{2}:\d{2}:\d{2}(\.\d{1,3})?)|(\d{2}:\d{2}))?(\s?([+-]\d{2}:\d{2}|Z))?$/;
var objectToZui = /* @__PURE__ */ __name((obj, opts, isRoot = true) => {
  if (typeof obj !== "object") {
    throw new Error("Input must be an object");
  }
  const applyOptions = /* @__PURE__ */ __name((zodType) => {
    let newType = zodType;
    if (opts == null ? void 0 : opts.nullable) {
      newType = newType.nullable();
    }
    if (opts == null ? void 0 : opts.optional) {
      newType = newType.optional();
    }
    if ((opts == null ? void 0 : opts.passtrough) && typeof newType.passthrough === "function") {
      newType = newType.passthrough();
    }
    return newType;
  }, "applyOptions");
  const schema = Object.entries(obj).reduce((acc, [key, value]) => {
    if (value === null) {
      acc[key] = applyOptions(z_exports.null());
    } else {
      switch (typeof value) {
        case "string":
          acc[key] = dateTimeRegex.test(value) ? applyOptions(z_exports.string().datetime()) : applyOptions(z_exports.string());
          break;
        case "number":
          acc[key] = applyOptions(z_exports.number());
          break;
        case "boolean":
          acc[key] = applyOptions(z_exports.boolean());
          break;
        case "object":
          if (Array.isArray(value)) {
            if (value.length === 0) {
              acc[key] = applyOptions(z_exports.array(z_exports.unknown()));
            } else if (typeof value[0] === "object") {
              acc[key] = applyOptions(z_exports.array(objectToZui(value[0], opts, false)));
            } else if (["string", "number", "boolean"].includes(typeof value[0])) {
              acc[key] = applyOptions(z_exports.array(z_exports[typeof value[0]]()));
            }
          } else {
            acc[key] = applyOptions(objectToZui(value, opts, false));
          }
          break;
        default:
          throw new Error(`Unsupported type for key ${key}`);
      }
    }
    return acc;
  }, {});
  const hasProperties = Object.keys(schema).length > 0;
  if ((opts == null ? void 0 : opts.passtrough) || !isRoot && !hasProperties) {
    return z_exports.object(schema).passthrough();
  }
  return z_exports.object(schema);
}, "objectToZui");

// src/transforms/zui-to-json-schema/parsers/any.ts
function parseAnyDef() {
  return {};
}
__name(parseAnyDef, "parseAnyDef");

// src/transforms/zui-to-json-schema/errorMessages.ts
function addErrorMessage(res, key, errorMessage, refs) {
  if (!(refs == null ? void 0 : refs.errorMessages))
    return;
  if (errorMessage) {
    res.errorMessage = __spreadProps(__spreadValues({}, res.errorMessage), {
      [key]: errorMessage
    });
  }
}
__name(addErrorMessage, "addErrorMessage");
function setResponseValueAndErrors(res, key, value, errorMessage, refs) {
  res[key] = value;
  addErrorMessage(res, key, errorMessage, refs);
}
__name(setResponseValueAndErrors, "setResponseValueAndErrors");

// src/transforms/zui-to-json-schema/parsers/array.ts
function parseArrayDef(def, refs) {
  var _a, _b;
  const res = {
    type: "array"
  };
  if (((_b = (_a = def.type) == null ? void 0 : _a._def) == null ? void 0 : _b.typeName) !== "ZodAny" /* ZodAny */) {
    res.items = parseDef(def.type._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "items"]
    }));
  }
  if (def.minLength) {
    setResponseValueAndErrors(res, "minItems", def.minLength.value, def.minLength.message, refs);
  }
  if (def.maxLength) {
    setResponseValueAndErrors(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
  }
  if (def.exactLength) {
    setResponseValueAndErrors(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
    setResponseValueAndErrors(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
  }
  return res;
}
__name(parseArrayDef, "parseArrayDef");

// src/transforms/zui-to-json-schema/parsers/bigint.ts
function parseBigintDef(def, refs) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}
__name(parseBigintDef, "parseBigintDef");

// src/transforms/zui-to-json-schema/parsers/boolean.ts
function parseBooleanDef() {
  return {
    type: "boolean"
  };
}
__name(parseBooleanDef, "parseBooleanDef");

// src/transforms/zui-to-json-schema/parsers/branded.ts
function parseBrandedDef(_def, refs) {
  return parseDef(_def.type._def, refs);
}
__name(parseBrandedDef, "parseBrandedDef");

// src/transforms/zui-to-json-schema/parsers/catch.ts
var parseCatchDef = /* @__PURE__ */ __name((def, refs) => {
  return parseDef(def.innerType._def, refs);
}, "parseCatchDef");

// src/transforms/zui-to-json-schema/parsers/date.ts
function parseDateDef(def, refs) {
  if (refs.dateStrategy == "integer") {
    return integerDateParser(def, refs);
  } else {
    return {
      type: "string",
      format: "date-time"
    };
  }
}
__name(parseDateDef, "parseDateDef");
var integerDateParser = /* @__PURE__ */ __name((def, refs) => {
  const res = {
    type: "integer",
    format: "unix-time"
  };
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        if (refs.target === "jsonSchema7") {
          setResponseValueAndErrors(
            res,
            "minimum",
            check.value,
            // This is in milliseconds
            check.message,
            refs
          );
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          setResponseValueAndErrors(
            res,
            "maximum",
            check.value,
            // This is in milliseconds
            check.message,
            refs
          );
        }
        break;
    }
  }
  return res;
}, "integerDateParser");

// src/transforms/zui-to-json-schema/parsers/default.ts
function parseDefaultDef(_def, refs) {
  return __spreadProps(__spreadValues({}, parseDef(_def.innerType._def, refs)), {
    default: _def.defaultValue()
  });
}
__name(parseDefaultDef, "parseDefaultDef");

// src/transforms/zui-to-json-schema/parsers/effects.ts
function parseEffectsDef(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs) : {};
}
__name(parseEffectsDef, "parseEffectsDef");

// src/transforms/zui-to-json-schema/parsers/enum.ts
function parseEnumDef(def) {
  return {
    type: "string",
    enum: def.values
  };
}
__name(parseEnumDef, "parseEnumDef");

// src/transforms/zui-to-json-schema/parsers/intersection.ts
var isJsonSchema7AllOfType = /* @__PURE__ */ __name((type) => {
  if ("type" in type && type.type === "string")
    return false;
  return "allOf" in type;
}, "isJsonSchema7AllOfType");
function parseIntersectionDef(def, refs) {
  const allOf = [
    parseDef(def.left._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "allOf", "0"]
    })),
    parseDef(def.right._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "allOf", "1"]
    }))
  ].filter((x) => !!x);
  let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : void 0;
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType(schema)) {
      mergedAllOf.push(...schema.allOf);
      if (schema.unevaluatedProperties === void 0) {
        unevaluatedProperties = void 0;
      }
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const _a = schema, { additionalProperties } = _a, rest = __objRest(_a, ["additionalProperties"]);
        nestedSchema = rest;
      } else {
        unevaluatedProperties = void 0;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? __spreadValues({
    allOf: mergedAllOf
  }, unevaluatedProperties) : void 0;
}
__name(parseIntersectionDef, "parseIntersectionDef");

// src/transforms/zui-to-json-schema/parsers/literal.ts
function parseLiteralDef(def, refs) {
  const parsedType = typeof def.value;
  if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  if (refs.target === "openApi3") {
    return {
      type: parsedType === "bigint" ? "integer" : parsedType,
      enum: [def.value]
    };
  }
  return {
    type: parsedType === "bigint" ? "integer" : parsedType,
    const: def.value
  };
}
__name(parseLiteralDef, "parseLiteralDef");

// src/transforms/zui-to-json-schema/parsers/string.ts
var zodPatterns = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: "^[cC][^\\s-]{8,}$",
  cuid2: "^[a-z][a-z0-9]*$",
  ulid: "^[0-9A-HJKMNP-TV-Z]{26}$",
  /**
   * `a-z` was added to replicate /i flag
   */
  email: "^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_+-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$",
  emoji: "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
  /**
   * Unused
   */
  uuid: "^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$",
  /**
   * Unused
   */
  ipv4: "^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$",
  /**
   * Unused
   */
  ipv6: "^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$"
};
function parseStringDef(def, refs) {
  const res = {
    type: "string"
  };
  function processPattern(value) {
    return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(value) : value;
  }
  __name(processPattern, "processPattern");
  if (def.checks) {
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          setResponseValueAndErrors(
            res,
            "minLength",
            typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value,
            check.message,
            refs
          );
          break;
        case "max":
          setResponseValueAndErrors(
            res,
            "maxLength",
            typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value,
            check.message,
            refs
          );
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat(res, "email", check.message, refs);
              break;
            case "format:idn-email":
              addFormat(res, "idn-email", check.message, refs);
              break;
            case "pattern:zod":
              addPattern(res, zodPatterns.email, check.message, refs);
              break;
          }
          break;
        case "url":
          addFormat(res, "uri", check.message, refs);
          break;
        case "uuid":
          addFormat(res, "uuid", check.message, refs);
          break;
        case "regex":
          addPattern(res, check.regex.source, check.message, refs);
          break;
        case "cuid":
          addPattern(res, zodPatterns.cuid, check.message, refs);
          break;
        case "cuid2":
          addPattern(res, zodPatterns.cuid2, check.message, refs);
          break;
        case "startsWith":
          addPattern(res, "^" + processPattern(check.value), check.message, refs);
          break;
        case "endsWith":
          addPattern(res, processPattern(check.value) + "$", check.message, refs);
          break;
        case "datetime":
          addFormat(res, "date-time", check.message, refs);
          break;
        case "length":
          setResponseValueAndErrors(
            res,
            "minLength",
            typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value,
            check.message,
            refs
          );
          setResponseValueAndErrors(
            res,
            "maxLength",
            typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value,
            check.message,
            refs
          );
          break;
        case "includes": {
          addPattern(res, processPattern(check.value), check.message, refs);
          break;
        }
        case "ip": {
          if (check.version !== "v6") {
            addFormat(res, "ipv4", check.message, refs);
          }
          if (check.version !== "v4") {
            addFormat(res, "ipv6", check.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern(res, zodPatterns.emoji, check.message, refs);
          break;
        case "ulid": {
          addPattern(res, zodPatterns.ulid, check.message, refs);
          break;
        }
        case "toLowerCase":
        case "toUpperCase":
        case "trim":
          break;
        default:
          ;
          /* @__PURE__ */ ((_) => {
          })(check);
      }
    }
  }
  return res;
}
__name(parseStringDef, "parseStringDef");
var escapeNonAlphaNumeric = /* @__PURE__ */ __name((value) => Array.from(value).map((c) => /[a-zA-Z0-9]/.test(c) ? c : `\\${c}`).join(""), "escapeNonAlphaNumeric");
var addFormat = /* @__PURE__ */ __name((schema, value, message, refs) => {
  var _a;
  if (schema.format || ((_a = schema.anyOf) == null ? void 0 : _a.some((x) => x.format))) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push(__spreadValues({
        format: schema.format
      }, schema.errorMessage && refs.errorMessages && {
        errorMessage: { format: schema.errorMessage.format }
      }));
      delete schema.format;
      if (schema.errorMessage) {
        delete schema.errorMessage.format;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.anyOf.push(__spreadValues({
      format: value
    }, message && refs.errorMessages && { errorMessage: { format: message } }));
  } else {
    setResponseValueAndErrors(schema, "format", value, message, refs);
  }
}, "addFormat");
var addPattern = /* @__PURE__ */ __name((schema, value, message, refs) => {
  var _a;
  if (schema.pattern || ((_a = schema.allOf) == null ? void 0 : _a.some((x) => x.pattern))) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push(__spreadValues({
        pattern: schema.pattern
      }, schema.errorMessage && refs.errorMessages && {
        errorMessage: { pattern: schema.errorMessage.pattern }
      }));
      delete schema.pattern;
      if (schema.errorMessage) {
        delete schema.errorMessage.pattern;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.allOf.push(__spreadValues({
      pattern: value
    }, message && refs.errorMessages && { errorMessage: { pattern: message } }));
  } else {
    setResponseValueAndErrors(schema, "pattern", value, message, refs);
  }
}, "addPattern");

// src/transforms/zui-to-json-schema/parsers/record.ts
function parseRecordDef(def, refs) {
  var _a, _b, _c, _d, _e;
  if (refs.target === "openApi3" && ((_a = def.keyType) == null ? void 0 : _a._def.typeName) === "ZodEnum" /* ZodEnum */) {
    return {
      type: "object",
      required: def.keyType._def.values,
      properties: def.keyType._def.values.reduce(
        (acc, key) => {
          var _a2;
          return __spreadProps(__spreadValues({}, acc), {
            [key]: (_a2 = parseDef(def.valueType._def, __spreadProps(__spreadValues({}, refs), {
              currentPath: [...refs.currentPath, "properties", key]
            }))) != null ? _a2 : {}
          });
        },
        {}
      ),
      additionalProperties: false
    };
  }
  const schema = {
    type: "object",
    additionalProperties: (_b = parseDef(def.valueType._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "additionalProperties"]
    }))) != null ? _b : {}
  };
  if (refs.target === "openApi3") {
    return schema;
  }
  if (((_c = def.keyType) == null ? void 0 : _c._def.typeName) === "ZodString" /* ZodString */ && ((_d = def.keyType._def.checks) == null ? void 0 : _d.length)) {
    const keyType = Object.entries(parseStringDef(def.keyType._def, refs)).reduce(
      (acc, [key, value]) => key === "type" ? acc : __spreadProps(__spreadValues({}, acc), { [key]: value }),
      {}
    );
    return __spreadProps(__spreadValues({}, schema), {
      propertyNames: keyType
    });
  } else if (((_e = def.keyType) == null ? void 0 : _e._def.typeName) === "ZodEnum" /* ZodEnum */) {
    return __spreadProps(__spreadValues({}, schema), {
      propertyNames: {
        enum: def.keyType._def.values
      }
    });
  }
  return schema;
}
__name(parseRecordDef, "parseRecordDef");

// src/transforms/zui-to-json-schema/parsers/map.ts
function parseMapDef(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef(def, refs);
  }
  const keys = parseDef(def.keyType._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "items", "items", "0"]
  })) || {};
  const values = parseDef(def.valueType._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "items", "items", "1"]
  })) || {};
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}
__name(parseMapDef, "parseMapDef");

// src/transforms/zui-to-json-schema/parsers/nativeEnum.ts
function parseNativeEnumDef(def) {
  const object = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object[object[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object[key]);
  const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues.filter(
      (value) => typeof value === "string" || typeof value === "number"
    )
  };
}
__name(parseNativeEnumDef, "parseNativeEnumDef");

// src/transforms/zui-to-json-schema/parsers/never.ts
function parseNeverDef() {
  return {
    not: {}
  };
}
__name(parseNeverDef, "parseNeverDef");

// src/transforms/zui-to-json-schema/parsers/null.ts
function parseNullDef(refs) {
  return refs.target === "openApi3" ? {
    enum: ["null"],
    nullable: true
  } : {
    type: "null"
  };
}
__name(parseNullDef, "parseNullDef");

// src/transforms/zui-to-json-schema/parsers/union.ts
var primitiveMappings = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function parseUnionDef(def, refs) {
  if (refs.target === "openApi3")
    return asUnionOf(def, refs);
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every((x) => x._def.typeName in primitiveMappings && (!x._def.checks || !x._def.checks.length))) {
    const types = options.reduce((types2, x) => {
      const type = primitiveMappings[x._def.typeName];
      return type && !types2.includes(type) ? [...types2, type] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types = options.reduce((acc, x) => {
      const type = typeof x._def.value;
      switch (type) {
        case "string":
        case "number":
        case "boolean":
          return [...acc, type];
        case "bigint":
          return [...acc, "integer"];
        case "object":
          if (x._def.value === null)
            return [...acc, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return acc;
      }
    }, []);
    if (types.length === options.length) {
      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce(
          (acc, x) => {
            return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
          },
          []
        )
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce(
        (acc, x) => [...acc, ...x._def.values.filter((x2) => !acc.includes(x2))],
        []
      )
    };
  }
  return asUnionOf(def, refs);
}
__name(parseUnionDef, "parseUnionDef");
var asUnionOf = /* @__PURE__ */ __name((def, refs) => {
  const unionOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map(
    (x, i) => parseDef(x._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, refs.unionStrategy, `${i}`]
    }))
  ).filter(
    (x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0)
  );
  const discriminator = refs.discriminator && def.typeName === "ZodDiscriminatedUnion" && typeof def.discriminator === "string" ? { discriminator: { propertyName: def.discriminator } } : {};
  if (!unionOf.length) {
    return void 0;
  }
  return refs.unionStrategy === "anyOf" ? __spreadValues({ anyOf: unionOf }, discriminator) : __spreadValues({ oneOf: unionOf }, discriminator);
}, "asUnionOf");

// src/transforms/zui-to-json-schema/parsers/nullable.ts
function parseNullableDef(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    if (refs.target === "openApi3") {
      return {
        type: primitiveMappings[def.innerType._def.typeName],
        nullable: true
      };
    }
    return {
      type: [primitiveMappings[def.innerType._def.typeName], "null"]
    };
  }
  if (refs.target === "openApi3") {
    const base2 = parseDef(def.innerType._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath]
    }));
    return base2 && __spreadProps(__spreadValues({}, base2), { nullable: true });
  }
  const base = parseDef(def.innerType._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "anyOf", "0"]
  }));
  return base && { anyOf: [base, { type: "null" }] };
}
__name(parseNullableDef, "parseNullableDef");

// src/transforms/zui-to-json-schema/parsers/number.ts
function parseNumberDef(def, refs) {
  const res = {
    type: "number"
  };
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "int":
        res.type = "integer";
        addErrorMessage(res, "type", check.message, refs);
        break;
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}
__name(parseNumberDef, "parseNumberDef");

// src/transforms/zui-to-json-schema/parsers/object.ts
function parseObjectDef(def, refs) {
  var _a;
  const result = __spreadProps(__spreadValues({
    type: "object"
  }, Object.entries(def.shape()).reduce(
    (acc, [propName, propDef]) => {
      if (propDef === void 0 || propDef._def === void 0)
        return acc;
      const parsedDef = parseDef(propDef._def, __spreadProps(__spreadValues({}, refs), {
        currentPath: [...refs.currentPath, "properties", propName],
        propertyPath: [...refs.currentPath, "properties", propName]
      }));
      if (parsedDef === void 0)
        return acc;
      return {
        properties: __spreadProps(__spreadValues({}, acc.properties), { [propName]: parsedDef }),
        required: propDef.isOptional() ? acc.required : [...acc.required, propName]
      };
    },
    { properties: {}, required: [] }
  )), {
    additionalProperties: def.catchall._def.typeName === "ZodNever" ? def.unknownKeys === "passthrough" : (_a = parseDef(def.catchall._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "additionalProperties"]
    }))) != null ? _a : true
  });
  if (!result.required.length)
    delete result.required;
  return result;
}
__name(parseObjectDef, "parseObjectDef");

// src/transforms/zui-to-json-schema/parsers/optional.ts
var parseOptionalDef = /* @__PURE__ */ __name((def, refs) => {
  var _a;
  if (refs.currentPath.toString() === ((_a = refs.propertyPath) == null ? void 0 : _a.toString())) {
    return parseDef(def.innerType._def, refs);
  }
  const innerSchema = parseDef(def.innerType._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "anyOf", "1"]
  }));
  return innerSchema ? {
    anyOf: [
      {
        not: {}
      },
      innerSchema
    ]
  } : {};
}, "parseOptionalDef");

// src/transforms/zui-to-json-schema/parsers/pipeline.ts
var parsePipelineDef = /* @__PURE__ */ __name((def, refs) => {
  if (refs.pipeStrategy === "input") {
    return parseDef(def.in._def, refs);
  } else if (refs.pipeStrategy === "output") {
    return parseDef(def.out._def, refs);
  }
  const a = parseDef(def.in._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "allOf", "0"]
  }));
  const b = parseDef(def.out._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
  }));
  return {
    allOf: [a, b].filter((x) => x !== void 0)
  };
}, "parsePipelineDef");

// src/transforms/zui-to-json-schema/parsers/promise.ts
function parsePromiseDef(def, refs) {
  return parseDef(def.type._def, refs);
}
__name(parsePromiseDef, "parsePromiseDef");

// src/transforms/zui-to-json-schema/parsers/set.ts
function parseSetDef(def, refs) {
  const items = parseDef(def.valueType._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "items"]
  }));
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    setResponseValueAndErrors(schema, "minItems", def.minSize.value, def.minSize.message, refs);
  }
  if (def.maxSize) {
    setResponseValueAndErrors(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
  }
  return schema;
}
__name(parseSetDef, "parseSetDef");

// src/transforms/zui-to-json-schema/parsers/tuple.ts
function parseTupleDef(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map(
        (x, i) => parseDef(x._def, __spreadProps(__spreadValues({}, refs), {
          currentPath: [...refs.currentPath, "items", `${i}`]
        }))
      ).reduce((acc, x) => x === void 0 ? acc : [...acc, x], []),
      additionalItems: parseDef(def.rest._def, __spreadProps(__spreadValues({}, refs), {
        currentPath: [...refs.currentPath, "additionalItems"]
      }))
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map(
        (x, i) => parseDef(x._def, __spreadProps(__spreadValues({}, refs), {
          currentPath: [...refs.currentPath, "items", `${i}`]
        }))
      ).reduce((acc, x) => x === void 0 ? acc : [...acc, x], [])
    };
  }
}
__name(parseTupleDef, "parseTupleDef");

// src/transforms/zui-to-json-schema/parsers/undefined.ts
function parseUndefinedDef() {
  return {
    not: {}
  };
}
__name(parseUndefinedDef, "parseUndefinedDef");

// src/transforms/zui-to-json-schema/parsers/unknown.ts
function parseUnknownDef() {
  return {};
}
__name(parseUnknownDef, "parseUnknownDef");

// src/transforms/zui-to-json-schema/parsers/readonly.ts
var parseReadonlyDef = /* @__PURE__ */ __name((def, refs) => {
  return parseDef(def.innerType._def, refs);
}, "parseReadonlyDef");

// src/ui/constants.ts
var zuiKey = "x-zui";

// src/transforms/zui-to-json-schema/parseDef.ts
function parseDef(def, refs, forceResolution = false) {
  const seenItem = refs.seen.get(def);
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref(seenItem, refs);
    if (seenSchema !== void 0) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchema = selectParser(def, def.typeName, refs);
  if (jsonSchema) {
    addMeta(def, refs, jsonSchema);
  }
  newItem.jsonSchema = jsonSchema;
  return jsonSchema;
}
__name(parseDef, "parseDef");
var get$ref = /* @__PURE__ */ __name((item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "relative":
      return { $ref: getRelativePath(refs.currentPath, item.path) };
    case "none":
    case "seen": {
      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
        console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
        return {};
      }
      return refs.$refStrategy === "seen" ? {} : void 0;
    }
  }
}, "get$ref");
var getRelativePath = /* @__PURE__ */ __name((pathA, pathB) => {
  let i = 0;
  for (; i < pathA.length && i < pathB.length; i++) {
    if (pathA[i] !== pathB[i])
      break;
  }
  return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
}, "getRelativePath");
var selectParser = /* @__PURE__ */ __name((def, typeName, refs) => {
  switch (typeName) {
    case "ZodString" /* ZodString */:
      return parseStringDef(def, refs);
    case "ZodNumber" /* ZodNumber */:
      return parseNumberDef(def, refs);
    case "ZodObject" /* ZodObject */:
      return parseObjectDef(def, refs);
    case "ZodBigInt" /* ZodBigInt */:
      return parseBigintDef(def, refs);
    case "ZodBoolean" /* ZodBoolean */:
      return parseBooleanDef();
    case "ZodDate" /* ZodDate */:
      return parseDateDef(def, refs);
    case "ZodUndefined" /* ZodUndefined */:
      return parseUndefinedDef();
    case "ZodNull" /* ZodNull */:
      return parseNullDef(refs);
    case "ZodArray" /* ZodArray */:
      return parseArrayDef(def, refs);
    case "ZodUnion" /* ZodUnion */:
    case "ZodDiscriminatedUnion" /* ZodDiscriminatedUnion */:
      return parseUnionDef(def, refs);
    case "ZodIntersection" /* ZodIntersection */:
      return parseIntersectionDef(def, refs);
    case "ZodTuple" /* ZodTuple */:
      return parseTupleDef(def, refs);
    case "ZodRecord" /* ZodRecord */:
      return parseRecordDef(def, refs);
    case "ZodLiteral" /* ZodLiteral */:
      return parseLiteralDef(def, refs);
    case "ZodEnum" /* ZodEnum */:
      return parseEnumDef(def);
    case "ZodNativeEnum" /* ZodNativeEnum */:
      return parseNativeEnumDef(def);
    case "ZodNullable" /* ZodNullable */:
      return parseNullableDef(def, refs);
    case "ZodOptional" /* ZodOptional */:
      return parseOptionalDef(def, refs);
    case "ZodMap" /* ZodMap */:
      return parseMapDef(def, refs);
    case "ZodSet" /* ZodSet */:
      return parseSetDef(def, refs);
    case "ZodLazy" /* ZodLazy */:
      return parseDef(def.getter()._def, refs);
    case "ZodPromise" /* ZodPromise */:
      return parsePromiseDef(def, refs);
    case "ZodNaN" /* ZodNaN */:
    case "ZodNever" /* ZodNever */:
      return parseNeverDef();
    case "ZodEffects" /* ZodEffects */:
      return parseEffectsDef(def, refs);
    case "ZodAny" /* ZodAny */:
      return parseAnyDef();
    case "ZodUnknown" /* ZodUnknown */:
      return parseUnknownDef();
    case "ZodDefault" /* ZodDefault */:
      return parseDefaultDef(def, refs);
    case "ZodBranded" /* ZodBranded */:
      return parseBrandedDef(def, refs);
    case "ZodReadonly" /* ZodReadonly */:
      return parseReadonlyDef(def, refs);
    case "ZodCatch" /* ZodCatch */:
      return parseCatchDef(def, refs);
    case "ZodPipeline" /* ZodPipeline */:
      return parsePipelineDef(def, refs);
    case "ZodTemplateLiteral" /* ZodTemplateLiteral */:
      throw new Error("Template literals are not supported yet");
    case "ZodFunction" /* ZodFunction */:
    case "ZodVoid" /* ZodVoid */:
    case "ZodSymbol" /* ZodSymbol */:
      return void 0;
    default:
      return /* @__PURE__ */ ((_) => void 0)(typeName);
  }
}, "selectParser");
var addMeta = /* @__PURE__ */ __name((def, refs, jsonSchema) => {
  if (def.description) {
    jsonSchema.description = def.description;
    if (refs.markdownDescription) {
      jsonSchema.markdownDescription = def.description;
    }
  }
  if (def[zuiKey]) {
    ;
    jsonSchema[zuiKey] = def[zuiKey];
  }
  return jsonSchema;
}, "addMeta");

// src/transforms/zui-to-json-schema/Options.ts
var defaultOptions = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "string",
  mapStrategy: "entries",
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: false,
  definitions: {},
  errorMessages: false,
  markdownDescription: false,
  patternStrategy: "escape",
  emailStrategy: "format:email",
  discriminator: false,
  unionStrategy: "anyOf"
};
var getDefaultOptions = /* @__PURE__ */ __name((options) => typeof options === "string" ? __spreadProps(__spreadValues({}, defaultOptions), {
  name: options
}) : __spreadValues(__spreadValues({}, defaultOptions), options), "getDefaultOptions");

// src/transforms/zui-to-json-schema/Refs.ts
var getRefs = /* @__PURE__ */ __name((options) => {
  const _options = getDefaultOptions(options);
  const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
  return __spreadProps(__spreadValues({}, _options), {
    currentPath,
    propertyPath: void 0,
    seen: new Map(
      Object.entries(_options.definitions).map(([name, def]) => [
        def._def,
        {
          def: def._def,
          path: [..._options.basePath, _options.definitionPath, name],
          // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
          jsonSchema: void 0
        }
      ])
    )
  });
}, "getRefs");

// src/transforms/zui-to-json-schema/zodToJsonSchema.ts
var zodToJsonSchema = /* @__PURE__ */ __name((schema, options) => {
  var _a;
  const refs = getRefs(options);
  const definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce(
    (acc, [name2, schema2]) => {
      var _a2;
      return __spreadProps(__spreadValues({}, acc), {
        [name2]: (_a2 = parseDef(
          schema2._def,
          __spreadProps(__spreadValues({}, refs), {
            currentPath: [...refs.basePath, refs.definitionPath, name2]
          }),
          true
        )) != null ? _a2 : {}
      });
    },
    {}
  ) : void 0;
  const name = typeof options === "string" ? options : options == null ? void 0 : options.name;
  const main = (_a = parseDef(
    schema._def,
    name === void 0 ? refs : __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.basePath, refs.definitionPath, name]
    }),
    false
  )) != null ? _a : {};
  const combined = name === void 0 ? definitions ? __spreadProps(__spreadValues({}, main), {
    [refs.definitionPath]: definitions
  }) : main : {
    $ref: [...refs.$refStrategy === "relative" ? [] : refs.basePath, refs.definitionPath, name].join("/"),
    [refs.definitionPath]: __spreadProps(__spreadValues({}, definitions), {
      [name]: main
    })
  };
  if (refs.target === "jsonSchema7") {
    combined.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (refs.target === "jsonSchema2019-09") {
    combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
  }
  return combined;
}, "zodToJsonSchema");

// src/transforms/zui-to-json-schema/zui-extension.ts
var zuiToJsonSchema = /* @__PURE__ */ __name((zuiType, opts = { target: "jsonSchema7" }) => {
  const jsonSchema = zodToJsonSchema(zuiType, opts);
  if (opts.$schemaUrl === false) {
    delete jsonSchema.$schema;
  } else if (typeof opts.$schemaUrl === "string") {
    jsonSchema.$schema = opts.$schemaUrl;
  }
  return mergeZuiIntoJsonSchema(jsonSchema, zuiType, opts);
}, "zuiToJsonSchema");
var isObject = /* @__PURE__ */ __name((schema) => (
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  schema.type === "object" && schema.properties
), "isObject");
var isArray = /* @__PURE__ */ __name((schema) => (
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  schema.type === "array"
), "isArray");
var getShape = /* @__PURE__ */ __name((zuiSchema) => {
  var _a, _b, _c, _d;
  if (!(zuiSchema == null ? void 0 : zuiSchema._def)) {
    return;
  }
  if (zuiSchema._def.getter && typeof zuiSchema._def.getter === "function") {
    return (_b = (_a = zuiSchema._def.getter()._def) == null ? void 0 : _a.shape) == null ? void 0 : _b.call(_a);
  }
  return (_d = (_c = zuiSchema._def).shape) == null ? void 0 : _d.call(_c);
}, "getShape");
var mergeZuiIntoJsonSchema = /* @__PURE__ */ __name((jsonSchema, zuiSchema, opts) => {
  const assignZuiProps = /* @__PURE__ */ __name((value, ui) => {
    if (!opts.stripZuiProps) {
      Object.assign(value, { [zuiKey]: ui });
    }
  }, "assignZuiProps");
  if (isObject(jsonSchema)) {
    for (const [key, value] of Object.entries(jsonSchema.properties)) {
      const shape = getShape(zuiSchema);
      if (shape == null ? void 0 : shape[key]) {
        const innerZui = shape[key].ui;
        assignZuiProps(value, innerZui);
        mergeZuiIntoJsonSchema(value, shape[key], opts);
      }
    }
  }
  if (isArray(jsonSchema)) {
    if (Array.isArray(jsonSchema.items)) {
      jsonSchema.items.forEach((item, index) => mergeZuiIntoJsonSchema(item, zuiSchema._def.typeOf[index], opts));
    } else if (jsonSchema.items) {
      mergeZuiIntoJsonSchema(jsonSchema.items, zuiSchema._def.typeOf, opts);
    }
  }
  if (zuiSchema && "ui" in zuiSchema && (zuiSchema == null ? void 0 : zuiSchema.ui)) {
    assignZuiProps(jsonSchema, zuiSchema.ui);
  }
  return jsonSchema;
}, "mergeZuiIntoJsonSchema");

// src/z/types/utils/index.ts
var util;
((util4) => {
  util4.assertEqual = /* @__PURE__ */ __name((val) => val, "assertEqual");
  function assertIs(_arg) {
  }
  util4.assertIs = assertIs;
  __name(assertIs, "assertIs");
  function assertNever(_x) {
    throw new Error();
  }
  util4.assertNever = assertNever;
  __name(assertNever, "assertNever");
  util4.arrayToEnum = /* @__PURE__ */ __name((items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  }, "arrayToEnum");
  util4.getValidEnumValues = /* @__PURE__ */ __name((obj) => {
    const validKeys = (0, util4.objectKeys)(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return (0, util4.objectValues)(filtered);
  }, "getValidEnumValues");
  util4.objectValues = /* @__PURE__ */ __name((obj) => {
    return (0, util4.objectKeys)(obj).map(function(e) {
      return obj[e];
    });
  }, "objectValues");
  util4.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util4.find = /* @__PURE__ */ __name((arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  }, "find");
  util4.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util4.joinValues = joinValues;
  __name(joinValues, "joinValues");
  util4.jsonStringifyReplacer = /* @__PURE__ */ __name((_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  }, "jsonStringifyReplacer");
})(util || (util = {}));
var objectUtil;
((objectUtil3) => {
  objectUtil3.mergeShapes = /* @__PURE__ */ __name((first, second) => {
    return __spreadValues(__spreadValues({}, first), second);
  }, "mergeShapes");
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = /* @__PURE__ */ __name((data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
}, "getParsedType");
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = /* @__PURE__ */ __name((iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error != null ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error != null ? invalid_type_error : ctx.defaultError };
  }, "customMap");
  return { errorMap: customMap, description };
}
__name(processCreateParams, "processCreateParams");

// src/z/types/error/index.ts
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = /* @__PURE__ */ __name((obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
}, "quotelessJson");
var _ZodError = class _ZodError extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = /* @__PURE__ */ __name((sub) => {
      this.issues = [...this.issues, sub];
    }, "addIssue");
    this.addIssues = /* @__PURE__ */ __name((subs = []) => {
      this.issues = [...this.issues, ...subs];
    }, "addIssues");
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      ;
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = /* @__PURE__ */ __name((error2) => {
      for (const issue of error2.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          ;
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    }, "processError");
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof _ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
__name(_ZodError, "ZodError");
_ZodError.create = /* @__PURE__ */ __name((issues) => {
  const error2 = new _ZodError(issues);
  return error2;
}, "create");
var ZodError = _ZodError;
var _ZodTemplateLiteralUnsupportedTypeError = class _ZodTemplateLiteralUnsupportedTypeError extends Error {
  constructor() {
    super("Unsupported zod type!");
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      ;
      this.__proto__ = actualProto;
    }
    this.name = "ZodTemplateLiteralUnsupportedTypeError";
  }
};
__name(_ZodTemplateLiteralUnsupportedTypeError, "ZodTemplateLiteralUnsupportedTypeError");
var ZodTemplateLiteralUnsupportedTypeError = _ZodTemplateLiteralUnsupportedTypeError;
var _ZodTemplateLiteralUnsupportedCheckError = class _ZodTemplateLiteralUnsupportedCheckError extends Error {
  constructor(typeKind, check) {
    super(`${typeKind}'s "${check}" check is not supported in template literals!`);
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      ;
      this.__proto__ = actualProto;
    }
    this.name = "ZodTemplateLiteralUnsupportedCheckError";
  }
};
__name(_ZodTemplateLiteralUnsupportedCheckError, "ZodTemplateLiteralUnsupportedCheckError");
var ZodTemplateLiteralUnsupportedCheckError = _ZodTemplateLiteralUnsupportedCheckError;
var overrideErrorMap = en_default;
function setErrorMap(map2) {
  overrideErrorMap = map2;
}
__name(setErrorMap, "setErrorMap");
function getErrorMap() {
  return overrideErrorMap;
}
__name(getErrorMap, "getErrorMap");

// src/z/types/utils/parseUtil.ts
var makeIssue = /* @__PURE__ */ __name((params) => {
  var _a;
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = __spreadProps(__spreadValues({}, issueData), {
    path: fullPath
  });
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map2 of maps) {
    errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return __spreadProps(__spreadValues({}, issueData), {
    path: fullPath,
    message: (_a = issueData.message) != null ? _a : errorMessage
  });
}, "makeIssue");
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      getErrorMap(),
      // then global override map
      en_default
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
__name(addIssueToContext, "addIssueToContext");
var _ParseStatus = class _ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
__name(_ParseStatus, "ParseStatus");
var ParseStatus = _ParseStatus;
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = /* @__PURE__ */ __name((value) => ({ status: "dirty", value }), "DIRTY");
var OK = /* @__PURE__ */ __name((value) => ({ status: "valid", value }), "OK");
var isAborted = /* @__PURE__ */ __name((x) => x.status === "aborted", "isAborted");
var isDirty = /* @__PURE__ */ __name((x) => x.status === "dirty", "isDirty");
var isValid = /* @__PURE__ */ __name((x) => x.status === "valid", "isValid");
var isAsync = /* @__PURE__ */ __name((x) => typeof Promise !== "undefined" && x instanceof Promise, "isAsync");

// src/z/types/utils/errorUtil.ts
var errorUtil;
((errorUtil2) => {
  errorUtil2.errToObj = /* @__PURE__ */ __name((message) => typeof message === "string" ? { message } : message || {}, "errToObj");
  errorUtil2.toString = /* @__PURE__ */ __name((message) => typeof message === "string" ? message : message == null ? void 0 : message.message, "toString");
})(errorUtil || (errorUtil = {}));

// src/transforms/zui-to-typescript/index.ts
import { cloneDeep, endsWith, merge, isEqual as isEqual2 } from "lodash";

// src/transforms/zui-to-typescript/generator.ts
import { memoize as memoize2, omit } from "lodash";

// src/transforms/zui-to-typescript/types/AST.ts
function hasComment(ast) {
  return "comment" in ast && ast.comment != null && ast.comment !== "" || // Compare to true because ast.deprecated might be undefined
  "deprecated" in ast && ast.deprecated === true;
}
__name(hasComment, "hasComment");
function hasStandaloneName(ast) {
  return "standaloneName" in ast && ast.standaloneName != null && ast.standaloneName !== "";
}
__name(hasStandaloneName, "hasStandaloneName");
var T_ANY = {
  type: "ANY"
};
var T_ANY_ADDITIONAL_PROPERTIES = {
  keyName: "[k: string]",
  type: "ANY"
};
var T_UNKNOWN = {
  type: "UNKNOWN"
};
var T_UNKNOWN_ADDITIONAL_PROPERTIES = {
  keyName: "[k: string]",
  type: "UNKNOWN"
};

// src/transforms/zui-to-typescript/utils.ts
import { deburr, isPlainObject as isPlainObject2, trim, upperFirst } from "lodash";

// src/transforms/zui-to-typescript/types/JSONSchema.ts
import memoize from "lodash/memoize";
import isPlainObject from "lodash/isPlainObject";
var Parent = Symbol("Parent");
var getRootSchema = memoize((schema) => {
  const parent = schema[Parent];
  if (!parent) {
    return schema;
  }
  return getRootSchema(parent);
});
function isBoolean(schema) {
  return schema === true || schema === false;
}
__name(isBoolean, "isBoolean");
function isPrimitive(schema) {
  return !isPlainObject(schema);
}
__name(isPrimitive, "isPrimitive");
function isCompound(schema) {
  return Array.isArray(schema.type) || "anyOf" in schema || "oneOf" in schema;
}
__name(isCompound, "isCompound");

// src/transforms/zui-to-typescript/utils.ts
var basename = /* @__PURE__ */ __name((path, suffix) => {
  const base = path.split("/").pop() || "";
  return suffix ? base.replaceAll(suffix, "") : base;
}, "basename");
var extname = /* @__PURE__ */ __name((path) => {
  const base = basename(path);
  const index = base.lastIndexOf(".");
  return index === -1 ? "" : base.slice(index);
}, "extname");
var BLACKLISTED_KEYS = /* @__PURE__ */ new Set([
  "id",
  "$defs",
  "$id",
  "$schema",
  "title",
  "description",
  "default",
  "multipleOf",
  "maximum",
  "exclusiveMaximum",
  "minimum",
  "exclusiveMinimum",
  "maxLength",
  "minLength",
  "pattern",
  "additionalItems",
  "items",
  "maxItems",
  "minItems",
  "uniqueItems",
  "maxProperties",
  "minProperties",
  "required",
  "additionalProperties",
  "definitions",
  "properties",
  "patternProperties",
  "dependencies",
  "enum",
  "type",
  "allOf",
  "anyOf",
  "oneOf",
  "not"
]);
function traverseObjectKeys(obj, callback, processed) {
  Object.keys(obj).forEach((k) => {
    if (obj[k] && typeof obj[k] === "object" && !Array.isArray(obj[k])) {
      traverse(obj[k], callback, processed, k);
    }
  });
}
__name(traverseObjectKeys, "traverseObjectKeys");
function traverseArray(arr, callback, processed) {
  arr.forEach((s, k) => traverse(s, callback, processed, k.toString()));
}
__name(traverseArray, "traverseArray");
function traverse(schema, callback, processed = /* @__PURE__ */ new Set(), key) {
  if (processed.has(schema)) {
    return;
  }
  processed.add(schema);
  callback(schema, key != null ? key : null);
  if (schema.anyOf) {
    traverseArray(schema.anyOf, callback, processed);
  }
  if (schema.allOf) {
    traverseArray(schema.allOf, callback, processed);
  }
  if (schema.oneOf) {
    traverseArray(schema.oneOf, callback, processed);
  }
  if (schema.properties) {
    traverseObjectKeys(schema.properties, callback, processed);
  }
  if (schema.patternProperties) {
    traverseObjectKeys(schema.patternProperties, callback, processed);
  }
  if (schema.additionalProperties && typeof schema.additionalProperties === "object") {
    traverse(schema.additionalProperties, callback, processed);
  }
  if (schema.items) {
    const { items } = schema;
    if (Array.isArray(items)) {
      traverseArray(items, callback, processed);
    } else {
      traverse(items, callback, processed);
    }
  }
  if (schema.additionalItems && typeof schema.additionalItems === "object") {
    traverse(schema.additionalItems, callback, processed);
  }
  if (schema.dependencies) {
    if (Array.isArray(schema.dependencies)) {
      traverseArray(schema.dependencies, callback, processed);
    } else {
      traverseObjectKeys(schema.dependencies, callback, processed);
    }
  }
  if (schema.definitions) {
    traverseObjectKeys(schema.definitions, callback, processed);
  }
  if (schema.$defs) {
    traverseObjectKeys(schema.$defs, callback, processed);
  }
  if (schema.not) {
    traverse(schema.not, callback, processed);
  }
  Object.keys(schema).filter((key2) => !BLACKLISTED_KEYS.has(key2)).forEach((key2) => {
    const child = schema[key2];
    if (child && typeof child === "object") {
      traverseObjectKeys(child, callback, processed);
    }
  });
}
__name(traverse, "traverse");
function justName(filename = "") {
  return stripExtension(basename(filename));
}
__name(justName, "justName");
function stripExtension(filename) {
  return filename.replace(extname(filename), "");
}
__name(stripExtension, "stripExtension");
function toSafeString(string) {
  return upperFirst(
    // remove accents, umlauts, ... by their basic latin letters
    deburr(string).replace(/(^\s*[^a-zA-Z_$])|([^a-zA-Z_$\d])/g, " ").replace(/^_[a-z]/g, (match) => match.toUpperCase()).replace(/_[a-z]/g, (match) => match.substr(1, match.length).toUpperCase()).replace(/([\d$]+[a-zA-Z])/g, (match) => match.toUpperCase()).replace(/\s+([a-zA-Z])/g, (match) => trim(match.toUpperCase())).replace(/\s/g, "")
  );
}
__name(toSafeString, "toSafeString");
function generateName(from, usedNames) {
  let name = toSafeString(from);
  if (!name) {
    name = "NoName";
  }
  if (usedNames.has(name)) {
    let counter = 1;
    let nameWithCounter = `${name}${counter}`;
    while (usedNames.has(nameWithCounter)) {
      nameWithCounter = `${name}${counter}`;
      counter++;
    }
    name = nameWithCounter;
  }
  usedNames.add(name);
  return name;
}
__name(generateName, "generateName");
function error(...messages) {
  if (!process.env.VERBOSE) {
    return console.error(messages);
  }
  console.error(...messages);
}
__name(error, "error");
function log(_, title, ...messages) {
  if (!process.env.VERBOSE) {
    return;
  }
  let lastMessage = null;
  if (messages.length > 1 && typeof messages[messages.length - 1] !== "string") {
    lastMessage = messages.splice(messages.length - 1, 1);
  }
  console.info(title, ...messages);
  if (lastMessage) {
    console.dir(lastMessage, { depth: 6, maxArrayLength: 6 });
  }
}
__name(log, "log");
function escapeBlockComment(schema) {
  const replacer = "* /";
  if (schema === null || typeof schema !== "object") {
    return;
  }
  for (const key of Object.keys(schema)) {
    if (key === "description" && typeof schema[key] === "string") {
      schema[key] = schema[key].replace(/\*\//g, replacer);
    }
  }
}
__name(escapeBlockComment, "escapeBlockComment");
function maybeStripDefault(schema) {
  if (!("default" in schema)) {
    return schema;
  }
  switch (schema.type) {
    case "array":
      if (Array.isArray(schema.default)) {
        return schema;
      }
      break;
    case "boolean":
      if (typeof schema.default === "boolean") {
        return schema;
      }
      break;
    case "integer":
    case "number":
      if (typeof schema.default === "number") {
        return schema;
      }
      break;
    case "string":
      if (typeof schema.default === "string") {
        return schema;
      }
      break;
    case "null":
      if (schema.default === null) {
        return schema;
      }
      break;
    case "object":
      if (isPlainObject2(schema.default)) {
        return schema;
      }
      break;
  }
  delete schema.default;
  return schema;
}
__name(maybeStripDefault, "maybeStripDefault");
function maybeStripNameHints(schema) {
  if ("$id" in schema) {
    delete schema.$id;
  }
  if ("description" in schema) {
    delete schema.description;
  }
  if ("name" in schema) {
    delete schema.name;
  }
  return schema;
}
__name(maybeStripNameHints, "maybeStripNameHints");
function appendToDescription(existingDescription, ...values) {
  if (existingDescription) {
    return `${existingDescription}

${values.join("\n")}`;
  }
  return values.join("\n");
}
__name(appendToDescription, "appendToDescription");
function isSchemaLike(schema) {
  if (!isPlainObject2(schema)) {
    return false;
  }
  const parent = schema[Parent];
  if (parent === null) {
    return true;
  }
  const JSON_SCHEMA_KEYWORDS = [
    "$defs",
    "allOf",
    "anyOf",
    "definitions",
    "dependencies",
    "enum",
    "not",
    "oneOf",
    "patternProperties",
    "properties",
    "required"
  ];
  if (JSON_SCHEMA_KEYWORDS.some((_) => parent[_] === schema)) {
    return false;
  }
  return true;
}
__name(isSchemaLike, "isSchemaLike");

// src/transforms/zui-to-typescript/generator.ts
function generate(ast, options = DEFAULT_OPTIONS) {
  return [
    options.bannerComment,
    declareNamedTypes(ast, options, ast.standaloneName),
    declareNamedInterfaces(ast, options, ast.standaloneName),
    declareEnums(ast, options)
  ].filter(Boolean).join("\n\n") + "\n";
}
__name(generate, "generate");
function declareEnums(ast, options, processed = /* @__PURE__ */ new Set()) {
  if (processed.has(ast)) {
    return "";
  }
  processed.add(ast);
  let type = "";
  switch (ast.type) {
    case "ENUM":
      return generateStandaloneEnum(ast, options) + "\n";
    case "ARRAY":
      return declareEnums(ast.params, options, processed);
    case "UNION":
    case "INTERSECTION":
      return ast.params.reduce((prev, ast2) => prev + declareEnums(ast2, options, processed), "");
    case "TUPLE":
      type = ast.params.reduce((prev, ast2) => prev + declareEnums(ast2, options, processed), "");
      if (ast.spreadParam) {
        type += declareEnums(ast.spreadParam, options, processed);
      }
      return type;
    case "INTERFACE":
      return getSuperTypesAndParams(ast).reduce((prev, ast2) => prev + declareEnums(ast2, options, processed), "");
    default:
      return "";
  }
}
__name(declareEnums, "declareEnums");
function declareNamedInterfaces(ast, options, rootASTName, processed = /* @__PURE__ */ new Set()) {
  if (processed.has(ast)) {
    return "";
  }
  processed.add(ast);
  let type = "";
  switch (ast.type) {
    case "ARRAY":
      type = declareNamedInterfaces(ast.params, options, rootASTName, processed);
      break;
    case "INTERFACE":
      type = [
        hasStandaloneName(ast) && (ast.standaloneName === rootASTName || options.declareExternallyReferenced) && generateStandaloneInterface(ast, options),
        getSuperTypesAndParams(ast).map((ast2) => declareNamedInterfaces(ast2, options, rootASTName, processed)).filter(Boolean).join("\n")
      ].filter(Boolean).join("\n");
      break;
    case "INTERSECTION":
    case "TUPLE":
    case "UNION":
      type = ast.params.map((_) => declareNamedInterfaces(_, options, rootASTName, processed)).filter(Boolean).join("\n");
      if (ast.type === "TUPLE" && ast.spreadParam) {
        type += declareNamedInterfaces(ast.spreadParam, options, rootASTName, processed);
      }
      break;
    default:
      type = "";
  }
  return type;
}
__name(declareNamedInterfaces, "declareNamedInterfaces");
function declareNamedTypes(ast, options, rootASTName, processed = /* @__PURE__ */ new Set()) {
  if (processed.has(ast)) {
    return "";
  }
  processed.add(ast);
  switch (ast.type) {
    case "ARRAY":
      return [
        declareNamedTypes(ast.params, options, rootASTName, processed),
        hasStandaloneName(ast) ? generateStandaloneType(ast, options) : void 0
      ].filter(Boolean).join("\n");
    case "ENUM":
      return "";
    case "INTERFACE":
      return getSuperTypesAndParams(ast).map(
        (ast2) => (ast2.standaloneName === rootASTName || options.declareExternallyReferenced) && declareNamedTypes(ast2, options, rootASTName, processed)
      ).filter(Boolean).join("\n");
    case "INTERSECTION":
    case "TUPLE":
    case "UNION":
      return [
        hasStandaloneName(ast) ? generateStandaloneType(ast, options) : void 0,
        ast.params.map((ast2) => declareNamedTypes(ast2, options, rootASTName, processed)).filter(Boolean).join("\n"),
        "spreadParam" in ast && ast.spreadParam ? declareNamedTypes(ast.spreadParam, options, rootASTName, processed) : void 0
      ].filter(Boolean).join("\n");
    default:
      if (hasStandaloneName(ast)) {
        return generateStandaloneType(ast, options);
      }
      return "";
  }
}
__name(declareNamedTypes, "declareNamedTypes");
function generateTypeUnmemoized(ast, options) {
  const type = generateRawType(ast, options);
  if (options.strictIndexSignatures && ast.keyName === "[k: string]") {
    return `${type} | undefined`;
  }
  return type;
}
__name(generateTypeUnmemoized, "generateTypeUnmemoized");
var generateType = memoize2(generateTypeUnmemoized);
function generateRawType(ast, options) {
  log("magenta", "generator", ast);
  if (hasStandaloneName(ast)) {
    return toSafeString(ast.standaloneName);
  }
  switch (ast.type) {
    case "ANY":
      return "any";
    case "ARRAY":
      return (() => {
        const type = generateType(ast.params, options);
        return type.endsWith('"') ? "(" + type + ")[]" : type + "[]";
      })();
    case "BOOLEAN":
      return "boolean";
    case "INTERFACE":
      return generateInterface(ast, options);
    case "INTERSECTION":
      return generateSetOperation(ast, options);
    case "LITERAL":
      return JSON.stringify(ast.params);
    case "NEVER":
      return "never";
    case "NUMBER":
      return "number";
    case "NULL":
      return "null";
    case "OBJECT":
      return "object";
    case "REFERENCE":
      return ast.params;
    case "STRING":
      return "string";
    case "TUPLE":
      return (() => {
        const minItems = ast.minItems;
        const maxItems = ast.maxItems || -1;
        let spreadParam = ast.spreadParam;
        const astParams = [...ast.params];
        if (minItems > 0 && minItems > astParams.length && ast.spreadParam === void 0) {
          if (maxItems < 0) {
            spreadParam = options.unknownAny ? T_UNKNOWN : T_ANY;
          }
        }
        if (maxItems > astParams.length && ast.spreadParam === void 0) {
          for (let i = astParams.length; i < maxItems; i += 1) {
            astParams.push(options.unknownAny ? T_UNKNOWN : T_ANY);
          }
        }
        function addSpreadParam(params) {
          if (spreadParam) {
            const spread = "...(" + generateType(spreadParam, options) + ")[]";
            params.push(spread);
          }
          return params;
        }
        __name(addSpreadParam, "addSpreadParam");
        function paramsToString(params) {
          return "[" + params.join(", ") + "]";
        }
        __name(paramsToString, "paramsToString");
        const paramsList = astParams.map((param) => generateType(param, options));
        if (paramsList.length > minItems) {
          const cumulativeParamsList = paramsList.slice(0, minItems);
          const typesToUnion = [];
          if (cumulativeParamsList.length > 0) {
            typesToUnion.push(paramsToString(cumulativeParamsList));
          } else {
            typesToUnion.push(paramsToString([]));
          }
          for (let i = minItems; i < paramsList.length; i += 1) {
            cumulativeParamsList.push(paramsList[i]);
            if (i === paramsList.length - 1) {
              addSpreadParam(cumulativeParamsList);
            }
            typesToUnion.push(paramsToString(cumulativeParamsList));
          }
          return typesToUnion.join("|");
        }
        return paramsToString(addSpreadParam(paramsList));
      })();
    case "UNION":
      return generateSetOperation(ast, options);
    case "UNKNOWN":
      return "unknown";
    case "CUSTOM_TYPE":
      return ast.params;
  }
}
__name(generateRawType, "generateRawType");
function generateSetOperation(ast, options) {
  const members = ast.params.map((_) => generateType(_, options));
  const separator = ast.type === "UNION" ? "|" : "&";
  return members.length === 1 ? members[0] : "(" + members.join(" " + separator + " ") + ")";
}
__name(generateSetOperation, "generateSetOperation");
function generateInterface(ast, options) {
  return "{\n" + ast.params.filter((_) => !_.isPatternProperty && !_.isUnreachableDefinition).map(
    ({ isRequired, keyName, ast: ast2 }) => [isRequired, keyName, ast2, generateType(ast2, options)]
  ).map(
    ([isRequired, keyName, ast2, type]) => (hasComment(ast2) && !ast2.standaloneName ? generateComment(ast2.comment, ast2.deprecated) + "\n" : "") + escapeKeyName(keyName) + (isRequired ? "" : "?") + ": " + type
  ).join("\n") + "\n}";
}
__name(generateInterface, "generateInterface");
function generateComment(comment, deprecated) {
  const commentLines = ["/**"];
  if (deprecated) {
    commentLines.push(" * @deprecated");
  }
  if (typeof comment !== "undefined") {
    commentLines.push(...comment.split("\n").map((_) => " * " + _));
  }
  commentLines.push(" */");
  return commentLines.join("\n");
}
__name(generateComment, "generateComment");
function generateStandaloneEnum(ast, options) {
  return (hasComment(ast) ? generateComment(ast.comment, ast.deprecated) + "\n" : "") + "export " + (options.enableConstEnums ? "const " : "") + `enum ${toSafeString(ast.standaloneName)} {
` + ast.params.map(({ ast: ast2, keyName }) => keyName + " = " + generateType(ast2, options)).join(",\n") + "\n}";
}
__name(generateStandaloneEnum, "generateStandaloneEnum");
function generateStandaloneInterface(ast, options) {
  return (hasComment(ast) ? generateComment(ast.comment, ast.deprecated) + "\n" : "") + `export interface ${toSafeString(ast.standaloneName)} ` + (ast.superTypes.length > 0 ? `extends ${ast.superTypes.map((superType) => toSafeString(superType.standaloneName)).join(", ")} ` : "") + generateInterface(ast, options);
}
__name(generateStandaloneInterface, "generateStandaloneInterface");
function generateStandaloneType(ast, options) {
  return (hasComment(ast) ? generateComment(ast.comment) + "\n" : "") + `export type ${toSafeString(ast.standaloneName)} = ${generateType(
    omit(ast, "standaloneName"),
    options
  )}`;
}
__name(generateStandaloneType, "generateStandaloneType");
function escapeKeyName(keyName) {
  if (keyName.length && /[A-Za-z_$]/.test(keyName.charAt(0)) && /^[\w$]+$/.test(keyName)) {
    return keyName;
  }
  if (keyName === "[k: string]") {
    return keyName;
  }
  return JSON.stringify(keyName);
}
__name(escapeKeyName, "escapeKeyName");
function getSuperTypesAndParams(ast) {
  return ast.params.map((param) => param.ast).concat(ast.superTypes);
}
__name(getSuperTypesAndParams, "getSuperTypesAndParams");

// src/transforms/zui-to-typescript/linker.ts
import isPlainObject3 from "lodash/isPlainObject";
function link(schema, parent = null) {
  if (!Array.isArray(schema) && !isPlainObject3(schema)) {
    return schema;
  }
  if (schema.hasOwnProperty(Parent)) {
    return schema;
  }
  Object.defineProperty(schema, Parent, {
    enumerable: false,
    value: parent,
    writable: false
  });
  if (Array.isArray(schema)) {
    schema.forEach((child) => link(child, schema));
  }
  for (const key in schema) {
    link(schema[key], schema);
  }
  return schema;
}
__name(link, "link");

// src/transforms/zui-to-typescript/normalizer.ts
import isEqual from "lodash/isEqual";
import isEmpty from "lodash/isEmpty";
var rules = /* @__PURE__ */ new Map();
function hasType(schema, type) {
  return schema.type === type || Array.isArray(schema.type) && schema.type.includes(type);
}
__name(hasType, "hasType");
function isObjectType(schema) {
  return schema.properties !== void 0 || hasType(schema, "object") || hasType(schema, "any");
}
__name(isObjectType, "isObjectType");
function isArrayType(schema) {
  return schema.items !== void 0 || hasType(schema, "array") || hasType(schema, "any");
}
__name(isArrayType, "isArrayType");
rules.set('Remove `type=["null"]` if `enum=[null]`', (schema) => {
  if (Array.isArray(schema.enum) && schema.enum.some((e) => e === null) && Array.isArray(schema.type) && schema.type.includes("null")) {
    schema.type = schema.type.filter((type) => type !== "null");
  }
});
rules.set("Destructure unary types", (schema) => {
  if (schema.type && Array.isArray(schema.type) && schema.type.length === 1) {
    schema.type = schema.type[0];
  }
});
rules.set("Add empty `required` property if none is defined", (schema) => {
  if (isObjectType(schema) && !("required" in schema)) {
    schema.required = [];
  }
});
rules.set("Transform `required`=false to `required`=[]", (schema) => {
  if (schema.required === false) {
    schema.required = [];
  }
});
rules.set("Default additionalProperties", (schema, _, options) => {
  if (isObjectType(schema) && !("additionalProperties" in schema) && schema.patternProperties === void 0) {
    schema.additionalProperties = options.additionalProperties;
  }
});
rules.set("Transform id to $id", (schema, fileName) => {
  if (!isSchemaLike(schema)) {
    return;
  }
  if (schema.id && schema.$id && schema.id !== schema.$id) {
    throw ReferenceError(
      `Schema must define either id or $id, not both. Given id=${schema.id}, $id=${schema.$id} in ${fileName}`
    );
  }
  if (schema.id) {
    schema.$id = schema.id;
    delete schema.id;
  }
});
rules.set("Add an $id to anything that needs it", (schema, fileName, _options, _key, dereferencedPaths) => {
  if (!isSchemaLike(schema)) {
    return;
  }
  if (!schema.$id && !schema[Parent]) {
    let id = justName(fileName);
    id = isEmpty(id) ? "Root" : id;
    schema.$id = toSafeString(id);
    return;
  }
  if (!isArrayType(schema) && !isObjectType(schema)) {
    return;
  }
  const dereferencedName = dereferencedPaths.get(schema);
  if (!schema.$id && !schema.title && dereferencedName) {
    schema.$id = toSafeString(justName(dereferencedName));
  }
  if (dereferencedName) {
    dereferencedPaths.delete(schema);
  }
});
rules.set("Escape closing JSDoc comment", (schema) => {
  escapeBlockComment(schema);
});
rules.set("Add JSDoc comments for minItems and maxItems", (schema) => {
  if (!isArrayType(schema)) {
    return;
  }
  const commentsToAppend = [
    "minItems" in schema ? `@minItems ${schema.minItems}` : "",
    "maxItems" in schema ? `@maxItems ${schema.maxItems}` : ""
  ].filter(Boolean);
  if (commentsToAppend.length) {
    schema.description = appendToDescription(schema.description, ...commentsToAppend);
  }
});
rules.set("Optionally remove maxItems and minItems", (schema, _fileName, options) => {
  if (!isArrayType(schema)) {
    return;
  }
  if ("minItems" in schema && options.ignoreMinAndMaxItems) {
    delete schema.minItems;
  }
  if ("maxItems" in schema && (options.ignoreMinAndMaxItems || options.maxItems === -1)) {
    delete schema.maxItems;
  }
});
rules.set("Normalize schema.minItems", (schema, _fileName, options) => {
  if (options.ignoreMinAndMaxItems) {
    return;
  }
  if (!isArrayType(schema)) {
    return;
  }
  const { minItems } = schema;
  schema.minItems = typeof minItems === "number" ? minItems : 0;
});
rules.set("Remove maxItems if it is big enough to likely cause OOMs", (schema, _fileName, options) => {
  if (options.ignoreMinAndMaxItems || options.maxItems === -1) {
    return;
  }
  if (!isArrayType(schema)) {
    return;
  }
  const { maxItems, minItems } = schema;
  if (maxItems !== void 0 && maxItems - minItems > options.maxItems) {
    delete schema.maxItems;
  }
});
rules.set("Normalize schema.items", (schema, _fileName, options) => {
  if (options.ignoreMinAndMaxItems) {
    return;
  }
  const { maxItems, minItems } = schema;
  const hasMaxItems = typeof maxItems === "number" && maxItems >= 0;
  const hasMinItems = typeof minItems === "number" && minItems > 0;
  if (schema.items && !Array.isArray(schema.items) && (hasMaxItems || hasMinItems)) {
    const items = schema.items;
    const newItems = Array(maxItems || minItems || 0).fill(items);
    if (!hasMaxItems) {
      schema.additionalItems = items;
    }
    schema.items = newItems;
  }
  if (Array.isArray(schema.items) && hasMaxItems && maxItems < schema.items.length) {
    schema.items = schema.items.slice(0, maxItems);
  }
  return schema;
});
rules.set("Remove extends, if it is empty", (schema) => {
  if (!schema.hasOwnProperty("extends")) {
    return;
  }
  if (schema.extends == null || Array.isArray(schema.extends) && schema.extends.length === 0) {
    delete schema.extends;
  }
});
rules.set("Make extends always an array, if it is defined", (schema) => {
  if (schema.extends == null) {
    return;
  }
  if (!Array.isArray(schema.extends)) {
    schema.extends = [schema.extends];
  }
});
rules.set("Transform definitions to $defs", (schema, fileName) => {
  if (schema.definitions && schema.$defs && !isEqual(schema.definitions, schema.$defs)) {
    throw ReferenceError(
      `Schema must define either definitions or $defs, not both. Given id=${schema.id} in ${fileName}`
    );
  }
  if (schema.definitions) {
    schema.$defs = schema.definitions;
    delete schema.definitions;
  }
});
rules.set("Transform const to singleton enum", (schema) => {
  if (schema.const !== void 0) {
    schema.enum = [schema.const];
    delete schema.const;
  }
});
function normalize(rootSchema, dereferencedPaths, filename, options) {
  rules.forEach(
    (rule) => traverse(rootSchema, (schema, key) => rule(schema, filename, options, key, dereferencedPaths))
  );
  return rootSchema;
}
__name(normalize, "normalize");

// src/transforms/zui-to-typescript/optimizer.ts
import uniqBy from "lodash/uniqBy";
function optimize(ast, options, processed = /* @__PURE__ */ new Set()) {
  if (processed.has(ast)) {
    return ast;
  }
  processed.add(ast);
  switch (ast.type) {
    case "INTERFACE":
      return Object.assign(ast, {
        params: ast.params.map((_) => Object.assign(_, { ast: optimize(_.ast, options, processed) }))
      });
    case "INTERSECTION":
    case "UNION":
      const optimizedAST = Object.assign(ast, {
        params: ast.params.map((_) => optimize(_, options, processed))
      });
      if (optimizedAST.params.some((_) => _.type === "ANY")) {
        log("cyan", "optimizer", "[A, B, C, Any] -> Any", optimizedAST);
        return T_ANY;
      }
      if (optimizedAST.params.some((_) => _.type === "UNKNOWN")) {
        log("cyan", "optimizer", "[A, B, C, Unknown] -> Unknown", optimizedAST);
        return T_UNKNOWN;
      }
      if (optimizedAST.params.every((_) => {
        const a = generateType(omitStandaloneName(_), options);
        const b = generateType(omitStandaloneName(optimizedAST.params[0]), options);
        return a === b;
      }) && optimizedAST.params.some((_) => _.standaloneName !== void 0)) {
        log("cyan", "optimizer", "[A (named), A] -> [A (named)]", optimizedAST);
        optimizedAST.params = optimizedAST.params.filter((_) => _.standaloneName !== void 0);
      }
      const params = uniqBy(optimizedAST.params, (_) => generateType(_, options));
      if (params.length !== optimizedAST.params.length) {
        log("cyan", "optimizer", "[A, B, B] -> [A, B]", optimizedAST);
        optimizedAST.params = params;
      }
      return Object.assign(optimizedAST, {
        params: optimizedAST.params.map((_) => optimize(_, options, processed))
      });
    default:
      return ast;
  }
}
__name(optimize, "optimize");
function omitStandaloneName(ast) {
  switch (ast.type) {
    case "ENUM":
      return ast;
    default:
      return __spreadProps(__spreadValues({}, ast), { standaloneName: void 0 });
  }
}
__name(omitStandaloneName, "omitStandaloneName");

// src/transforms/zui-to-typescript/optionValidator.ts
function validateOptions({ maxItems }) {
  if (maxItems !== void 0 && maxItems < -1) {
    throw RangeError(`Expected options.maxItems to be >= -1, but was given ${maxItems}.`);
  }
}
__name(validateOptions, "validateOptions");

// src/transforms/zui-to-typescript/parser.ts
import { findKey, includes, isPlainObject as isPlainObject5, map, memoize as memoize3, omit as omit2 } from "lodash";

// src/transforms/zui-to-typescript/typesOfSchema.ts
import isPlainObject4 from "lodash/isPlainObject";
function typesOfSchema(schema) {
  if (schema.tsType) {
    return ["CUSTOM_TYPE"];
  }
  const matchedTypes = [];
  for (const [schemaType, f] of Object.entries(matchers)) {
    if (f(schema)) {
      matchedTypes.push(schemaType);
    }
  }
  if (!matchedTypes.length) {
    return ["UNNAMED_SCHEMA"];
  }
  return matchedTypes;
}
__name(typesOfSchema, "typesOfSchema");
var matchers = {
  ALL_OF(schema) {
    return "allOf" in schema;
  },
  ANY(schema) {
    if (Object.keys(schema).length === 0) {
      return true;
    }
    return schema.type === "any";
  },
  ANY_OF(schema) {
    return "anyOf" in schema;
  },
  BOOLEAN(schema) {
    if ("enum" in schema) {
      return false;
    }
    if (schema.type === "boolean") {
      return true;
    }
    if (!isCompound(schema) && typeof schema.default === "boolean") {
      return true;
    }
    return false;
  },
  CUSTOM_TYPE() {
    return false;
  },
  NAMED_ENUM(schema) {
    return "enum" in schema && "tsEnumNames" in schema;
  },
  NAMED_SCHEMA(schema) {
    return "$id" in schema && ("patternProperties" in schema || "properties" in schema);
  },
  NEVER(schema) {
    return schema === false;
  },
  NULL(schema) {
    return schema.type === "null";
  },
  NUMBER(schema) {
    if ("enum" in schema) {
      return false;
    }
    if (schema.type === "integer" || schema.type === "number") {
      return true;
    }
    if (!isCompound(schema) && typeof schema.default === "number") {
      return true;
    }
    return false;
  },
  OBJECT(schema) {
    return schema.type === "object" && !isPlainObject4(schema.additionalProperties) && !schema.allOf && !schema.anyOf && !schema.oneOf && !schema.patternProperties && !schema.properties && !schema.required;
  },
  ONE_OF(schema) {
    return "oneOf" in schema;
  },
  REFERENCE(schema) {
    return "$ref" in schema;
  },
  STRING(schema) {
    if ("enum" in schema) {
      return false;
    }
    if (schema.type === "string") {
      return true;
    }
    if (!isCompound(schema) && typeof schema.default === "string") {
      return true;
    }
    return false;
  },
  TYPED_ARRAY(schema) {
    if (schema.type && schema.type !== "array") {
      return false;
    }
    return "items" in schema;
  },
  UNION(schema) {
    return Array.isArray(schema.type);
  },
  UNNAMED_ENUM(schema) {
    if ("tsEnumNames" in schema) {
      return false;
    }
    if (schema.type && schema.type !== "boolean" && schema.type !== "integer" && schema.type !== "number" && schema.type !== "string") {
      return false;
    }
    return "enum" in schema;
  },
  UNNAMED_SCHEMA() {
    return false;
  },
  UNTYPED_ARRAY(schema) {
    return schema.type === "array" && !("items" in schema);
  }
};

// src/transforms/zui-to-typescript/parser.ts
function parse(schema, options, keyName, processed = /* @__PURE__ */ new Map(), usedNames = /* @__PURE__ */ new Set()) {
  if (isPrimitive(schema)) {
    if (isBoolean(schema)) {
      return parseBooleanSchema(schema, keyName, options);
    }
    return parseLiteral(schema, keyName);
  }
  const types = typesOfSchema(schema);
  if (types.length === 1) {
    const ast2 = parseAsTypeWithCache(schema, types[0], options, keyName, processed, usedNames);
    log("blue", "parser", "Types:", types, "Input:", schema, "Output:", ast2);
    return ast2;
  }
  const ast = parseAsTypeWithCache(
    {
      $id: schema.$id,
      allOf: [],
      description: schema.description,
      title: schema.title
    },
    "ALL_OF",
    options,
    keyName,
    processed,
    usedNames
  );
  ast.params = types.map(
    (type) => (
      // We hoist description (for comment) and id/title (for standaloneName)
      // to the parent intersection type, so we remove it from the children.
      parseAsTypeWithCache(maybeStripNameHints(schema), type, options, keyName, processed, usedNames)
    )
  );
  log("blue", "parser", "Types:", types, "Input:", schema, "Output:", ast);
  return ast;
}
__name(parse, "parse");
function parseAsTypeWithCache(schema, type, options, keyName, processed = /* @__PURE__ */ new Map(), usedNames = /* @__PURE__ */ new Set()) {
  let cachedTypeMap = processed.get(schema);
  if (!cachedTypeMap) {
    cachedTypeMap = /* @__PURE__ */ new Map();
    processed.set(schema, cachedTypeMap);
  }
  const cachedAST = cachedTypeMap.get(type);
  if (cachedAST) {
    return cachedAST;
  }
  const ast = {};
  cachedTypeMap.set(type, ast);
  return Object.assign(ast, parseNonLiteral(schema, type, options, keyName, processed, usedNames));
}
__name(parseAsTypeWithCache, "parseAsTypeWithCache");
function parseBooleanSchema(schema, keyName, options) {
  if (schema) {
    return {
      keyName,
      type: options.unknownAny ? "UNKNOWN" : "ANY"
    };
  }
  return {
    keyName,
    type: "NEVER"
  };
}
__name(parseBooleanSchema, "parseBooleanSchema");
function parseLiteral(schema, keyName) {
  return {
    keyName,
    params: schema,
    type: "LITERAL"
  };
}
__name(parseLiteral, "parseLiteral");
function parseNonLiteral(schema, type, options, keyName, processed, usedNames) {
  const definitions = getDefinitionsMemoized(getRootSchema(schema));
  const keyNameFromDefinition = findKey(definitions, (_) => _ === schema);
  switch (type) {
    case "ALL_OF":
      return {
        comment: schema.description,
        deprecated: schema.deprecated,
        keyName,
        standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
        params: schema.allOf.map((_) => parse(_, options, void 0, processed, usedNames)),
        type: "INTERSECTION"
      };
    case "ANY":
      return __spreadProps(__spreadValues({}, options.unknownAny ? T_UNKNOWN : T_ANY), {
        comment: schema.description,
        deprecated: schema.deprecated,
        keyName,
        standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames)
      });
    case "ANY_OF":
      return {
        comment: schema.description,
        deprecated: schema.deprecated,
        keyName,
        standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
        params: schema.anyOf.map((_) => parse(_, options, void 0, processed, usedNames)),
        type: "UNION"
      };
    case "BOOLEAN":
      return {
        comment: schema.description,
        deprecated: schema.deprecated,
        keyName,
        standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
        type: "BOOLEAN"
      };
    case "CUSTOM_TYPE":
      return {
        comment: schema.description,
        deprecated: schema.deprecated,
        keyName,
        params: schema.tsType,
        standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
        type: "CUSTOM_TYPE"
      };
    case "NAMED_ENUM":
      return {
        comment: schema.description,
        deprecated: schema.deprecated,
        keyName,
        standaloneName: standaloneName(schema, keyNameFromDefinition != null ? keyNameFromDefinition : keyName, usedNames),
        params: schema.enum.map((_, n) => ({
          ast: parseLiteral(_, void 0),
          keyName: schema.tsEnumNames[n]
        })),
        type: "ENUM"
      };
    case "NAMED_SCHEMA":
      return newInterface(schema, options, processed, usedNames, keyName);
    case "NEVER":
      return {
        comment: schema.description,
        deprecated: schema.deprecated,
        keyName,
        standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
        type: "NEVER"
      };
    case "NULL":
      return {
        comment: schema.description,
        deprecated: schema.deprecated,
        keyName,
        standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
        type: "NULL"
      };
    case "NUMBER":
      return {
        comment: schema.description,
        deprecated: schema.deprecated,
        keyName,
        standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
        type: "NUMBER"
      };
    case "OBJECT":
      return {
        comment: schema.description,
        keyName,
        standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
        type: "OBJECT",
        deprecated: schema.deprecated
      };
    case "ONE_OF":
      return {
        comment: schema.description,
        deprecated: schema.deprecated,
        keyName,
        standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
        params: schema.oneOf.map((_) => parse(_, options, void 0, processed, usedNames)),
        type: "UNION"
      };
    case "REFERENCE":
      throw Error("Refs should have been resolved by the resolver!" + schema);
    case "STRING":
      return {
        comment: schema.description,
        deprecated: schema.deprecated,
        keyName,
        standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
        type: "STRING"
      };
    case "TYPED_ARRAY":
      if (Array.isArray(schema.items)) {
        const minItems2 = schema.minItems;
        const maxItems2 = schema.maxItems;
        const arrayType2 = {
          comment: schema.description,
          deprecated: schema.deprecated,
          keyName,
          maxItems: maxItems2,
          minItems: minItems2,
          standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
          params: schema.items.map((_) => parse(_, options, void 0, processed, usedNames)),
          type: "TUPLE"
        };
        if (schema.additionalItems === true) {
          arrayType2.spreadParam = options.unknownAny ? T_UNKNOWN : T_ANY;
        } else if (schema.additionalItems) {
          arrayType2.spreadParam = parse(schema.additionalItems, options, void 0, processed, usedNames);
        }
        return arrayType2;
      } else {
        return {
          comment: schema.description,
          deprecated: schema.deprecated,
          keyName,
          standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
          params: parse(schema.items, options, "{keyNameFromDefinition}Items", processed, usedNames),
          type: "ARRAY"
        };
      }
    case "UNION":
      return {
        comment: schema.description,
        deprecated: schema.deprecated,
        keyName,
        standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
        params: schema.type.map((type2) => {
          const member = __spreadProps(__spreadValues({}, omit2(schema, "$id", "description", "title")), { type: type2 });
          return parse(maybeStripDefault(member), options, void 0, processed, usedNames);
        }),
        type: "UNION"
      };
    case "UNNAMED_ENUM":
      return {
        comment: schema.description,
        deprecated: schema.deprecated,
        keyName,
        standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
        params: schema.enum.map((_) => parseLiteral(_, void 0)),
        type: "UNION"
      };
    case "UNNAMED_SCHEMA":
      return newInterface(schema, options, processed, usedNames, keyName, keyNameFromDefinition);
    case "UNTYPED_ARRAY":
      const minItems = schema.minItems;
      const maxItems = typeof schema.maxItems === "number" ? schema.maxItems : -1;
      const params = options.unknownAny ? T_UNKNOWN : T_ANY;
      if (minItems > 0 || maxItems >= 0) {
        return {
          comment: schema.description,
          deprecated: schema.deprecated,
          keyName,
          maxItems: schema.maxItems,
          minItems,
          // create a tuple of length N
          params: Array(Math.max(maxItems, minItems) || 0).fill(params),
          // if there is no maximum, then add a spread item to collect the rest
          spreadParam: maxItems >= 0 ? void 0 : params,
          standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
          type: "TUPLE"
        };
      }
      return {
        comment: schema.description,
        deprecated: schema.deprecated,
        keyName,
        params,
        standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
        type: "ARRAY"
      };
  }
}
__name(parseNonLiteral, "parseNonLiteral");
function standaloneName(schema, keyNameFromDefinition, usedNames) {
  const name = schema.title || schema.$id || keyNameFromDefinition;
  if (name) {
    return generateName(name, usedNames);
  }
}
__name(standaloneName, "standaloneName");
function newInterface(schema, options, processed, usedNames, keyName, keyNameFromDefinition) {
  const name = standaloneName(schema, keyNameFromDefinition, usedNames);
  return {
    comment: schema.description,
    deprecated: schema.deprecated,
    keyName,
    params: parseSchema(schema, options, processed, usedNames, name),
    standaloneName: name,
    superTypes: parseSuperTypes(schema, options, processed, usedNames),
    type: "INTERFACE"
  };
}
__name(newInterface, "newInterface");
function parseSuperTypes(schema, options, processed, usedNames) {
  const superTypes = schema.extends;
  if (!superTypes) {
    return [];
  }
  return superTypes.map((_) => parse(_, options, void 0, processed, usedNames));
}
__name(parseSuperTypes, "parseSuperTypes");
function parseSchema(schema, options, processed, usedNames, parentSchemaName) {
  let asts = map(schema.properties, (value, key) => ({
    ast: parse(value, options, key, processed, usedNames),
    isPatternProperty: false,
    isRequired: includes(schema.required || [], key),
    isUnreachableDefinition: false,
    keyName: key
  }));
  let singlePatternProperty = false;
  if (schema.patternProperties) {
    singlePatternProperty = !schema.additionalProperties && Object.keys(schema.patternProperties).length === 1;
    asts = asts.concat(
      map(schema.patternProperties, (value, key) => {
        const ast = parse(value, options, key, processed, usedNames);
        const comment = `This interface was referenced by \`${parentSchemaName}\`'s JSON-Schema definition
via the \`patternProperty\` "${key.replace("*/", "*\\/")}".`;
        ast.comment = ast.comment ? `${ast.comment}

${comment}` : comment;
        return {
          ast,
          isPatternProperty: !singlePatternProperty,
          isRequired: singlePatternProperty || includes(schema.required || [], key),
          isUnreachableDefinition: false,
          keyName: singlePatternProperty ? "[k: string]" : key
        };
      })
    );
  }
  if (options.unreachableDefinitions) {
    asts = asts.concat(
      map(schema.$defs, (value, key) => {
        const ast = parse(value, options, key, processed, usedNames);
        const comment = `This interface was referenced by \`${parentSchemaName}\`'s JSON-Schema
via the \`definition\` "${key}".`;
        ast.comment = ast.comment ? `${ast.comment}

${comment}` : comment;
        return {
          ast,
          isPatternProperty: false,
          isRequired: includes(schema.required || [], key),
          isUnreachableDefinition: true,
          keyName: key
        };
      })
    );
  }
  switch (schema.additionalProperties) {
    case void 0:
    case true:
      if (singlePatternProperty) {
        return asts;
      }
      return asts.concat({
        ast: options.unknownAny ? T_UNKNOWN_ADDITIONAL_PROPERTIES : T_ANY_ADDITIONAL_PROPERTIES,
        isPatternProperty: false,
        isRequired: true,
        isUnreachableDefinition: false,
        keyName: "[k: string]"
      });
    case false:
      return asts;
    default:
      return asts.concat({
        ast: parse(schema.additionalProperties, options, "[k: string]", processed, usedNames),
        isPatternProperty: false,
        isRequired: true,
        isUnreachableDefinition: false,
        keyName: "[k: string]"
      });
  }
}
__name(parseSchema, "parseSchema");
function getDefinitions(schema, isSchema = true, processed = /* @__PURE__ */ new Set()) {
  if (processed.has(schema)) {
    return {};
  }
  processed.add(schema);
  if (Array.isArray(schema)) {
    return schema.reduce(
      (prev, cur) => __spreadValues(__spreadValues({}, prev), getDefinitions(cur, false, processed)),
      {}
    );
  }
  if (isPlainObject5(schema)) {
    return __spreadValues(__spreadValues({}, isSchema && hasDefinitions(schema) ? schema.$defs : {}), Object.keys(schema).reduce(
      (prev, cur) => __spreadValues(__spreadValues({}, prev), getDefinitions(schema[cur], false, processed)),
      {}
    ));
  }
  return {};
}
__name(getDefinitions, "getDefinitions");
var getDefinitionsMemoized = memoize3(getDefinitions);
function hasDefinitions(schema) {
  return "$defs" in schema;
}
__name(hasDefinitions, "hasDefinitions");

// src/transforms/zui-to-typescript/resolver.ts
import $RefParser from "@apidevtools/json-schema-ref-parser";
async function dereference(schema, { cwd, $refOptions }) {
  log("green", "dereferencer", "Dereferencing input schema:", cwd, schema);
  const parser = new $RefParser();
  const dereferencedPaths = /* @__PURE__ */ new WeakMap();
  const dereferencedSchema = await parser.dereference(cwd, schema, __spreadProps(__spreadValues({}, $refOptions), {
    dereference: __spreadProps(__spreadValues({}, $refOptions.dereference), {
      onDereference($ref, schema2) {
        dereferencedPaths.set(schema2, $ref);
      }
    })
  }));
  return { dereferencedPaths, dereferencedSchema };
}
__name(dereference, "dereference");

// src/transforms/zui-to-typescript/validator.ts
var rules2 = /* @__PURE__ */ new Map();
rules2.set("Enum members and tsEnumNames must be of the same length", (schema) => {
  if (schema.enum && schema.tsEnumNames && schema.enum.length !== schema.tsEnumNames.length) {
    return false;
  }
});
rules2.set("tsEnumNames must be an array of strings", (schema) => {
  if (schema.tsEnumNames && schema.tsEnumNames.some((_) => typeof _ !== "string")) {
    return false;
  }
});
rules2.set("When both maxItems and minItems are present, maxItems >= minItems", (schema) => {
  const { maxItems, minItems } = schema;
  if (typeof maxItems === "number" && typeof minItems === "number") {
    return maxItems >= minItems;
  }
});
rules2.set("When maxItems exists, maxItems >= 0", (schema) => {
  const { maxItems } = schema;
  if (typeof maxItems === "number") {
    return maxItems >= 0;
  }
});
rules2.set("When minItems exists, minItems >= 0", (schema) => {
  const { minItems } = schema;
  if (typeof minItems === "number") {
    return minItems >= 0;
  }
});
rules2.set("deprecated must be a boolean", (schema) => {
  const typeOfDeprecated = typeof schema.deprecated;
  return typeOfDeprecated === "boolean" || typeOfDeprecated === "undefined";
});
function validate(schema, filename) {
  const errors = [];
  rules2.forEach((rule, ruleName) => {
    traverse(schema, (schema2, key) => {
      if (rule(schema2) === false) {
        errors.push(`Error at key "${key}" in file "${filename}": ${ruleName}`);
      }
      return schema2;
    });
  });
  return errors;
}
__name(validate, "validate");

// src/transforms/zui-to-typescript/index.ts
var DEFAULT_OPTIONS = {
  $refOptions: {},
  additionalProperties: true,
  // TODO: default to empty schema (as per spec) instead
  bannerComment: "",
  cwd: "",
  declareExternallyReferenced: true,
  enableConstEnums: true,
  format: true,
  ignoreMinAndMaxItems: false,
  maxItems: 20,
  strictIndexSignatures: false,
  unreachableDefinitions: false,
  unknownAny: true
};
async function compile(schema, name = "Root", options = {}) {
  validateOptions(options);
  const _options = merge({}, DEFAULT_OPTIONS, options);
  const start = Date.now();
  function time() {
    return `(${Date.now() - start}ms)`;
  }
  __name(time, "time");
  if (!endsWith(_options.cwd, "/")) {
    _options.cwd += "/";
  }
  const _schema = cloneDeep(schema);
  const { dereferencedPaths, dereferencedSchema } = await dereference(_schema, _options);
  if (process.env.VERBOSE) {
    if (isEqual2(_schema, dereferencedSchema)) {
      log("green", "dereferencer", time(), "\u2705 No change");
    } else {
      log("green", "dereferencer", time(), "\u2705 Result:", dereferencedSchema);
    }
  }
  const linked = link(dereferencedSchema);
  if (process.env.VERBOSE) {
    log("green", "linker", time(), "\u2705 No change");
  }
  const errors = validate(linked, name);
  if (errors.length) {
    errors.forEach((_) => error(_));
    throw new ValidationError();
  }
  if (process.env.VERBOSE) {
    log("green", "validator", time(), "\u2705 No change");
  }
  const normalized = normalize(linked, dereferencedPaths, name, _options);
  log("yellow", "normalizer", time(), "\u2705 Result:", normalized);
  const parsed = parse(normalized, _options);
  log("blue", "parser", time(), "\u2705 Result:", parsed);
  const optimized = optimize(parsed, _options);
  log("cyan", "optimizer", time(), "\u2705 Result:", optimized);
  const generated = generate(optimized, _options);
  log("magenta", "generator", time(), "\u2705 Result:", generated);
  return generated;
}
__name(compile, "compile");
var _ValidationError = class _ValidationError extends Error {
};
__name(_ValidationError, "ValidationError");
var ValidationError = _ValidationError;
var toTypescriptTypings = /* @__PURE__ */ __name(async (jsonSchema, options) => {
  var _a;
  const generatedType = await compile(jsonSchema, (_a = options == null ? void 0 : options.schemaName) != null ? _a : "Schema", __spreadValues({
    bannerComment: ""
  }, options));
  return !(options == null ? void 0 : options.schemaName) ? generatedType.replace("export interface Schema ", "").replace("export type Schema = ", "") : generatedType;
}, "toTypescriptTypings");

// src/z/types/basetype/index.ts
var _ParseInputLazyPath = class _ParseInputLazyPath {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
__name(_ParseInputLazyPath, "ParseInputLazyPath");
var ParseInputLazyPath = _ParseInputLazyPath;
var handleResult = /* @__PURE__ */ __name((ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error2 = new ZodError(ctx.common.issues);
        this._error = error2;
        return this._error;
      }
    };
  }
}, "handleResult");
var _ZodType = class _ZodType {
  constructor(def) {
    /** Alias of safeParseAsync */
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input4) {
    return getParsedType(input4.data);
  }
  _getOrReturnCtx(input4, ctx) {
    return ctx || {
      common: input4.parent.common,
      data: input4.data,
      parsedType: getParsedType(input4.data),
      schemaErrorMap: this._def.errorMap,
      path: input4.path,
      parent: input4.parent
    };
  }
  _processInputParams(input4) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input4.parent.common,
        data: input4.data,
        parsedType: getParsedType(input4.data),
        schemaErrorMap: this._def.errorMap,
        path: input4.path,
        parent: input4.parent
      }
    };
  }
  _parseSync(input4) {
    const result = this._parse(input4);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input4) {
    const result = this._parse(input4);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params == null ? void 0 : params.async) != null ? _a : false,
        contextualErrorMap: params == null ? void 0 : params.errorMap
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params == null ? void 0 : params.errorMap,
        async: true
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = /* @__PURE__ */ __name((val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    }, "getIssueProperties");
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = /* @__PURE__ */ __name(() => ctx.addIssue(__spreadValues({
        code: ZodIssueCode.custom
      }, getIssueProperties(val))), "setError");
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: "ZodEffects" /* ZodEffects */,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects(__spreadProps(__spreadValues({}, processCreateParams(this._def)), {
      schema: this,
      typeName: "ZodEffects" /* ZodEffects */,
      effect: { type: "transform", transform }
    }));
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault(__spreadProps(__spreadValues({}, processCreateParams(this._def)), {
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: "ZodDefault" /* ZodDefault */
    }));
  }
  brand() {
    return new ZodBranded(__spreadValues({
      typeName: "ZodBranded" /* ZodBranded */,
      type: this
    }, processCreateParams(this._def)));
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch(__spreadProps(__spreadValues({}, processCreateParams(this._def)), {
      innerType: this,
      catchValue: catchValueFunc,
      typeName: "ZodCatch" /* ZodCatch */
    }));
  }
  describe(description) {
    const This = this.constructor;
    return new This(__spreadProps(__spreadValues({}, this._def), {
      description
    }));
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
  // BOTPRESS EXTENSIONS
  _setZuiMeta(key, value) {
    const def = this._def;
    switch (def.typeName) {
      case "ZodNullable" /* ZodNullable */:
      case "ZodDefault" /* ZodDefault */:
      case "ZodOptional" /* ZodOptional */:
      case "ZodReadonly" /* ZodReadonly */:
        def.innerType._def[zuiKey] = __spreadProps(__spreadValues({}, def.innerType._def[zuiKey]), {
          [key]: value
        });
        break;
      case "ZodEffects" /* ZodEffects */:
        def.schema._def[zuiKey] = __spreadProps(__spreadValues({}, def.schema._def[zuiKey]), {
          [key]: value
        });
        break;
      default:
        def[zuiKey] = __spreadProps(__spreadValues({}, def[zuiKey]), {
          [key]: value
        });
    }
  }
  get ui() {
    const def = this._def;
    switch (def.typeName) {
      case "ZodNullable" /* ZodNullable */:
      case "ZodDefault" /* ZodDefault */:
      case "ZodOptional" /* ZodOptional */:
      case "ZodReadonly" /* ZodReadonly */:
        return def.innerType.ui;
      case "ZodEffects" /* ZodEffects */:
        return def.schema.ui;
      default:
        return def[zuiKey] || {};
    }
  }
  /**
   * The type of component to use to display the field and its options
   */
  displayAs(options) {
    var _a, _b, _c;
    (_c = (_a = this._def)[_b = zuiKey]) != null ? _c : _a[_b] = {};
    this._def[zuiKey].displayAs = [options.id, options.params];
    return this;
  }
  /**
   * The title of the field. Defaults to the field name.
   */
  title(title) {
    this._setZuiMeta("title", title);
    return this;
  }
  /**
   * Whether the field is hidden in the UI. Useful for internal fields.
   * @default false
   */
  hidden(hidden) {
    this._setZuiMeta("hidden", typeof hidden === "undefined" ? true : hidden);
    return this;
  }
  /**
   * Whether the field is disabled
   * @default false
   */
  disabled(disabled) {
    this._setZuiMeta("disabled", typeof disabled === "undefined" ? true : disabled);
    return this;
  }
  /**
   * Placeholder text for the field
   */
  placeholder(placeholder) {
    this._setZuiMeta("placeholder", placeholder);
    return this;
  }
  toJsonSchema(opts) {
    return zuiToJsonSchema(this, opts);
  }
  async toTypescriptTypings(opts) {
    return toTypescriptTypings(this.toJsonSchema(), opts);
  }
  static fromObject(obj, opts) {
    return objectToZui(obj, opts);
  }
  static fromJsonSchema(schema) {
    return jsonSchemaToZui(schema);
  }
};
__name(_ZodType, "ZodType");
var ZodType = _ZodType;

// src/z/types/defs.ts
var ZodFirstPartyTypeKind = /* @__PURE__ */ ((ZodFirstPartyTypeKind3) => {
  ZodFirstPartyTypeKind3["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind3["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind3["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind3["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind3["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind3["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind3["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind3["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind3["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind3["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind3["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind3["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind3["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind3["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind3["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind3["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind3["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind3["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind3["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind3["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind3["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind3["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind3["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind3["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind3["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind3["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind3["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind3["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind3["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind3["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind3["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind3["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind3["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind3["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind3["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind3["ZodTemplateLiteral"] = "ZodTemplateLiteral";
  ZodFirstPartyTypeKind3["ZodReadonly"] = "ZodReadonly";
  return ZodFirstPartyTypeKind3;
})(ZodFirstPartyTypeKind || {});

// src/z/types/any/index.ts
var _ZodAny = class _ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.
    this._any = true;
  }
  _parse(input4) {
    return OK(input4.data);
  }
};
__name(_ZodAny, "ZodAny");
_ZodAny.create = /* @__PURE__ */ __name((params) => {
  return new _ZodAny(__spreadValues({
    typeName: "ZodAny" /* ZodAny */
  }, processCreateParams(params)));
}, "create");
var ZodAny = _ZodAny;

// src/z/types/array/index.ts
var _ZodArray = class _ZodArray extends ZodType {
  _parse(input4) {
    const { ctx, status } = this._processInputParams(input4);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all(
        [...ctx.data].map((item, i) => {
          return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        })
      ).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new _ZodArray(__spreadProps(__spreadValues({}, this._def), {
      minLength: { value: minLength, message: errorUtil.toString(message) }
    }));
  }
  max(maxLength, message) {
    return new _ZodArray(__spreadProps(__spreadValues({}, this._def), {
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    }));
  }
  length(len, message) {
    return new _ZodArray(__spreadProps(__spreadValues({}, this._def), {
      exactLength: { value: len, message: errorUtil.toString(message) }
    }));
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
__name(_ZodArray, "ZodArray");
_ZodArray.create = /* @__PURE__ */ __name((schema, params) => {
  return new _ZodArray(__spreadValues({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: "ZodArray" /* ZodArray */
  }, processCreateParams(params)));
}, "create");
var ZodArray = _ZodArray;

// src/z/types/bigint/index.ts
var _ZodBigInt = class _ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input4) {
    if (this._def.coerce) {
      input4.data = BigInt(input4.data);
    }
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input4);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input4.data < check.value : input4.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input4.data > check.value : input4.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input4.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input4.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodBigInt(__spreadProps(__spreadValues({}, this._def), {
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    }));
  }
  _addCheck(check) {
    return new _ZodBigInt(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, check]
    }));
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
__name(_ZodBigInt, "ZodBigInt");
_ZodBigInt.create = /* @__PURE__ */ __name((params) => {
  var _a;
  return new _ZodBigInt(__spreadValues({
    checks: [],
    typeName: "ZodBigInt" /* ZodBigInt */,
    coerce: (_a = params == null ? void 0 : params.coerce) != null ? _a : false
  }, processCreateParams(params)));
}, "create");
var ZodBigInt = _ZodBigInt;

// src/z/types/boolean/index.ts
var _ZodBoolean = class _ZodBoolean extends ZodType {
  _parse(input4) {
    if (this._def.coerce) {
      input4.data = Boolean(input4.data);
    }
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input4);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input4.data);
  }
};
__name(_ZodBoolean, "ZodBoolean");
_ZodBoolean.create = /* @__PURE__ */ __name((params) => {
  return new _ZodBoolean(__spreadValues({
    typeName: "ZodBoolean" /* ZodBoolean */,
    coerce: (params == null ? void 0 : params.coerce) || false
  }, processCreateParams(params)));
}, "create");
var ZodBoolean = _ZodBoolean;

// src/z/types/branded/index.ts
var BRAND = Symbol("zod_brand");
var _ZodBranded = class _ZodBranded extends ZodType {
  _parse(input4) {
    const { ctx } = this._processInputParams(input4);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
__name(_ZodBranded, "ZodBranded");
var ZodBranded = _ZodBranded;

// src/z/types/catch/index.ts
var _ZodCatch = class _ZodCatch extends ZodType {
  _parse(input4) {
    const { ctx } = this._processInputParams(input4);
    const newCtx = __spreadProps(__spreadValues({}, ctx), {
      common: __spreadProps(__spreadValues({}, ctx.common), {
        issues: []
      })
    });
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: __spreadValues({}, newCtx)
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
__name(_ZodCatch, "ZodCatch");
_ZodCatch.create = /* @__PURE__ */ __name((type, params) => {
  return new _ZodCatch(__spreadValues({
    innerType: type,
    typeName: "ZodCatch" /* ZodCatch */,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch
  }, processCreateParams(params)));
}, "create");
var ZodCatch = _ZodCatch;

// src/z/types/custom/index.ts
var custom = /* @__PURE__ */ __name((check, params = {}, fatal) => {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      if (!check(data)) {
        const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a = p.fatal) != null ? _a : fatal) != null ? _b : true;
        const p2 = typeof p === "string" ? { message: p } : p;
        ctx.addIssue(__spreadProps(__spreadValues({ code: "custom" }, p2), { fatal: _fatal }));
      }
    });
  return ZodAny.create();
}, "custom");

// src/z/types/date/index.ts
var _ZodDate = class _ZodDate extends ZodType {
  _parse(input4) {
    if (this._def.coerce) {
      input4.data = new Date(input4.data);
    }
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input4);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input4.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input4);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input4.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input4.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input4.data.getTime())
    };
  }
  _addCheck(check) {
    return new _ZodDate(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, check]
    }));
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
__name(_ZodDate, "ZodDate");
_ZodDate.create = /* @__PURE__ */ __name((params) => {
  return new _ZodDate(__spreadValues({
    checks: [],
    coerce: (params == null ? void 0 : params.coerce) || false,
    typeName: "ZodDate" /* ZodDate */
  }, processCreateParams(params)));
}, "create");
var ZodDate = _ZodDate;

// src/z/types/default/index.ts
var _ZodDefault = class _ZodDefault extends ZodType {
  _parse(input4) {
    const { ctx } = this._processInputParams(input4);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
__name(_ZodDefault, "ZodDefault");
_ZodDefault.create = /* @__PURE__ */ __name((type, params) => {
  return new _ZodDefault(__spreadValues({
    innerType: type,
    typeName: "ZodDefault" /* ZodDefault */,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default
  }, processCreateParams(params)));
}, "create");
var ZodDefault = _ZodDefault;

// src/z/types/enum/index.ts
function createZodEnum(values, params) {
  return new ZodEnum(__spreadValues({
    values,
    typeName: "ZodEnum" /* ZodEnum */
  }, processCreateParams(params)));
}
__name(createZodEnum, "createZodEnum");
var _ZodEnum = class _ZodEnum extends ZodType {
  _parse(input4) {
    if (typeof input4.data !== "string") {
      const ctx = this._getOrReturnCtx(input4);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input4.data) === -1) {
      const ctx = this._getOrReturnCtx(input4);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input4.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return _ZodEnum.create(values, __spreadValues(__spreadValues({}, this._def), newDef));
  }
  exclude(values, newDef = this._def) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), __spreadValues(__spreadValues({}, this._def), newDef));
  }
};
__name(_ZodEnum, "ZodEnum");
_ZodEnum.create = createZodEnum;
var ZodEnum = _ZodEnum;

// src/z/types/lazy/index.ts
var _ZodLazy = class _ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input4) {
    const { ctx } = this._processInputParams(input4);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
__name(_ZodLazy, "ZodLazy");
_ZodLazy.create = /* @__PURE__ */ __name((getter, params) => {
  return new _ZodLazy(__spreadValues({
    getter,
    typeName: "ZodLazy" /* ZodLazy */
  }, processCreateParams(params)));
}, "create");
var ZodLazy = _ZodLazy;

// src/z/types/literal/index.ts
var _ZodLiteral = class _ZodLiteral extends ZodType {
  _parse(input4) {
    if (input4.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input4);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input4.data };
  }
  get value() {
    return this._def.value;
  }
};
__name(_ZodLiteral, "ZodLiteral");
_ZodLiteral.create = /* @__PURE__ */ __name((value, params) => {
  return new _ZodLiteral(__spreadValues({
    value,
    typeName: "ZodLiteral" /* ZodLiteral */
  }, processCreateParams(params)));
}, "create");
var ZodLiteral = _ZodLiteral;

// src/z/types/nativeEnum/index.ts
var _ZodNativeEnum = class _ZodNativeEnum extends ZodType {
  _parse(input4) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input4);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input4.data) === -1) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input4.data);
  }
  get enum() {
    return this._def.values;
  }
};
__name(_ZodNativeEnum, "ZodNativeEnum");
_ZodNativeEnum.create = /* @__PURE__ */ __name((values, params) => {
  return new _ZodNativeEnum(__spreadValues({
    values,
    typeName: "ZodNativeEnum" /* ZodNativeEnum */
  }, processCreateParams(params)));
}, "create");
var ZodNativeEnum = _ZodNativeEnum;

// src/z/types/null/index.ts
var _ZodNull = class _ZodNull extends ZodType {
  _parse(input4) {
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input4);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input4.data);
  }
};
__name(_ZodNull, "ZodNull");
_ZodNull.create = /* @__PURE__ */ __name((params) => {
  return new _ZodNull(__spreadValues({
    typeName: "ZodNull" /* ZodNull */
  }, processCreateParams(params)));
}, "create");
var ZodNull = _ZodNull;

// src/z/types/nullable/index.ts
var _ZodNullable = class _ZodNullable extends ZodType {
  _parse(input4) {
    const parsedType = this._getType(input4);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input4);
  }
  unwrap() {
    return this._def.innerType;
  }
};
__name(_ZodNullable, "ZodNullable");
_ZodNullable.create = /* @__PURE__ */ __name((type, params) => {
  return new _ZodNullable(__spreadValues({
    innerType: type,
    typeName: "ZodNullable" /* ZodNullable */
  }, processCreateParams(params)));
}, "create");
var ZodNullable = _ZodNullable;

// src/z/types/optional/index.ts
var _ZodOptional = class _ZodOptional extends ZodType {
  _parse(input4) {
    const parsedType = this._getType(input4);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input4);
  }
  unwrap() {
    return this._def.innerType;
  }
};
__name(_ZodOptional, "ZodOptional");
_ZodOptional.create = /* @__PURE__ */ __name((type, params) => {
  return new _ZodOptional(__spreadValues({
    innerType: type,
    typeName: "ZodOptional" /* ZodOptional */
  }, processCreateParams(params)));
}, "create");
var ZodOptional = _ZodOptional;

// src/z/types/readonly/index.ts
var _ZodReadonly = class _ZodReadonly extends ZodType {
  _parse(input4) {
    const result = this._def.innerType._parse(input4);
    if (isValid(result)) {
      result.value = Object.freeze(result.value);
    }
    return result;
  }
  unwrap() {
    return this._def.innerType;
  }
};
__name(_ZodReadonly, "ZodReadonly");
_ZodReadonly.create = /* @__PURE__ */ __name((type, params) => {
  return new _ZodReadonly(__spreadValues({
    innerType: type,
    typeName: "ZodReadonly" /* ZodReadonly */
  }, processCreateParams(params)));
}, "create");
var ZodReadonly = _ZodReadonly;

// src/z/types/transformer/index.ts
var _ZodEffects = class _ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === "ZodEffects" /* ZodEffects */ ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input4) {
    const { status, ctx } = this._processInputParams(input4);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = /* @__PURE__ */ __name((acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      }, "executeRefinement");
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(
            `Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`
          );
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util.assertNever(effect);
  }
};
__name(_ZodEffects, "ZodEffects");
_ZodEffects.create = /* @__PURE__ */ __name((schema, effect, params) => {
  return new _ZodEffects(__spreadValues({
    schema,
    typeName: "ZodEffects" /* ZodEffects */,
    effect
  }, processCreateParams(params)));
}, "create");
_ZodEffects.createWithPreprocess = /* @__PURE__ */ __name((preprocess, schema, params) => {
  return new _ZodEffects(__spreadValues({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: "ZodEffects" /* ZodEffects */
  }, processCreateParams(params)));
}, "createWithPreprocess");
var ZodEffects = _ZodEffects;

// src/z/types/undefined/index.ts
var _ZodUndefined = class _ZodUndefined extends ZodType {
  _parse(input4) {
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input4);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input4.data);
  }
};
__name(_ZodUndefined, "ZodUndefined");
_ZodUndefined.create = /* @__PURE__ */ __name((params) => {
  return new _ZodUndefined(__spreadValues({
    typeName: "ZodUndefined" /* ZodUndefined */
  }, processCreateParams(params)));
}, "create");
var ZodUndefined = _ZodUndefined;

// src/z/types/discriminatedUnion/index.ts
var getDiscriminator = /* @__PURE__ */ __name((type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
}, "getDiscriminator");
var _ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  _parse(input4) {
    const { ctx } = this._processInputParams(input4);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(
          `A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`
        );
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new _ZodDiscriminatedUnion(__spreadValues({
      typeName: "ZodDiscriminatedUnion" /* ZodDiscriminatedUnion */,
      discriminator,
      options,
      optionsMap
    }, processCreateParams(params)));
  }
};
__name(_ZodDiscriminatedUnion, "ZodDiscriminatedUnion");
var ZodDiscriminatedUnion = _ZodDiscriminatedUnion;

// src/z/types/promise/index.ts
var _ZodPromise = class _ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input4) {
    const { ctx } = this._processInputParams(input4);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(
      promisified.then((data) => {
        return this._def.type.parseAsync(data, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap
        });
      })
    );
  }
};
__name(_ZodPromise, "ZodPromise");
_ZodPromise.create = /* @__PURE__ */ __name((schema, params) => {
  return new _ZodPromise(__spreadValues({
    type: schema,
    typeName: "ZodPromise" /* ZodPromise */
  }, processCreateParams(params)));
}, "create");
var ZodPromise = _ZodPromise;

// src/z/types/tuple/index.ts
var _ZodTuple = class _ZodTuple extends ZodType {
  _parse(input4) {
    const { status, ctx } = this._processInputParams(input4);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple(__spreadProps(__spreadValues({}, this._def), {
      rest
    }));
  }
};
__name(_ZodTuple, "ZodTuple");
_ZodTuple.create = /* @__PURE__ */ __name((schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new _ZodTuple(__spreadValues({
    items: schemas,
    typeName: "ZodTuple" /* ZodTuple */,
    rest: null
  }, processCreateParams(params)));
}, "create");
var ZodTuple = _ZodTuple;

// src/z/types/unknown/index.ts
var _ZodUnknown = class _ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    // required
    this._unknown = true;
  }
  _parse(input4) {
    return OK(input4.data);
  }
};
__name(_ZodUnknown, "ZodUnknown");
_ZodUnknown.create = /* @__PURE__ */ __name((params) => {
  return new _ZodUnknown(__spreadValues({
    typeName: "ZodUnknown" /* ZodUnknown */
  }, processCreateParams(params)));
}, "create");
var ZodUnknown = _ZodUnknown;

// src/z/types/function/index.ts
var _ZodFunction = class _ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input4) {
    const { ctx } = this._processInputParams(input4);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error2) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter(
          (x) => !!x
        ),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error2
        }
      });
    }
    __name(makeArgsIssue, "makeArgsIssue");
    function makeReturnsIssue(returns, error2) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter(
          (x) => !!x
        ),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error2
        }
      });
    }
    __name(makeReturnsIssue, "makeReturnsIssue");
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error2 = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error2.addIssue(makeArgsIssue(args, e));
          throw error2;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error2.addIssue(makeReturnsIssue(result, e));
          throw error2;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction(__spreadProps(__spreadValues({}, this._def), {
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    }));
  }
  returns(returnType) {
    return new _ZodFunction(__spreadProps(__spreadValues({}, this._def), {
      returns: returnType
    }));
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new _ZodFunction(__spreadValues({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: "ZodFunction" /* ZodFunction */
    }, processCreateParams(params)));
  }
};
__name(_ZodFunction, "ZodFunction");
var ZodFunction = _ZodFunction;

// src/z/types/intersection/index.ts
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = __spreadValues(__spreadValues({}, a), b);
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
__name(mergeValues, "mergeValues");
var _ZodIntersection = class _ZodIntersection extends ZodType {
  _parse(input4) {
    const { status, ctx } = this._processInputParams(input4);
    const handleParsed = /* @__PURE__ */ __name((parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    }, "handleParsed");
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(
        this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      );
    }
  }
};
__name(_ZodIntersection, "ZodIntersection");
_ZodIntersection.create = /* @__PURE__ */ __name((left, right, params) => {
  return new _ZodIntersection(__spreadValues({
    left,
    right,
    typeName: "ZodIntersection" /* ZodIntersection */
  }, processCreateParams(params)));
}, "create");
var ZodIntersection = _ZodIntersection;

// src/z/types/map/index.ts
var _ZodMap = class _ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input4) {
    const { status, ctx } = this._processInputParams(input4);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
__name(_ZodMap, "ZodMap");
_ZodMap.create = /* @__PURE__ */ __name((keyType, valueType, params) => {
  return new _ZodMap(__spreadValues({
    valueType,
    keyType,
    typeName: "ZodMap" /* ZodMap */
  }, processCreateParams(params)));
}, "create");
var ZodMap = _ZodMap;

// src/z/types/nan/index.ts
var _ZodNaN = class _ZodNaN extends ZodType {
  _parse(input4) {
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input4);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input4.data };
  }
};
__name(_ZodNaN, "ZodNaN");
_ZodNaN.create = /* @__PURE__ */ __name((params) => {
  return new _ZodNaN(__spreadValues({
    typeName: "ZodNaN" /* ZodNaN */
  }, processCreateParams(params)));
}, "create");
var ZodNaN = _ZodNaN;

// src/z/types/never/index.ts
var _ZodNever = class _ZodNever extends ZodType {
  _parse(input4) {
    const ctx = this._getOrReturnCtx(input4);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
__name(_ZodNever, "ZodNever");
_ZodNever.create = /* @__PURE__ */ __name((params) => {
  return new _ZodNever(__spreadValues({
    typeName: "ZodNever" /* ZodNever */
  }, processCreateParams(params)));
}, "create");
var ZodNever = _ZodNever;

// src/z/types/number/index.ts
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
__name(floatSafeRemainder, "floatSafeRemainder");
var _ZodNumber = class _ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input4) {
    if (this._def.coerce) {
      input4.data = Number(input4.data);
    }
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input4);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input4.data)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input4.data < check.value : input4.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input4.data > check.value : input4.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input4.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input4.data)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input4.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodNumber(__spreadProps(__spreadValues({}, this._def), {
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    }));
  }
  _addCheck(check) {
    return new _ZodNumber(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, check]
    }));
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
__name(_ZodNumber, "ZodNumber");
_ZodNumber.create = /* @__PURE__ */ __name((params) => {
  return new _ZodNumber(__spreadValues({
    checks: [],
    typeName: "ZodNumber" /* ZodNumber */,
    coerce: (params == null ? void 0 : params.coerce) || false
  }, processCreateParams(params)));
}, "create");
var ZodNumber = _ZodNumber;

// src/z/types/object/index.ts
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject(__spreadProps(__spreadValues({}, schema._def), {
      shape: () => newShape
    }));
  } else if (schema instanceof ZodArray) {
    return new ZodArray(__spreadProps(__spreadValues({}, schema._def), {
      type: deepPartialify(schema.element)
    }));
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
__name(deepPartialify, "deepPartialify");
var _ZodObject = class _ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    /**
     * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
     * If you want to pass through unknown properties, use `.passthrough()` instead.
     */
    this.nonstrict = this.passthrough;
    // extend<
    //   Augmentation extends ZodRawShape,
    //   NewOutput extends util.flatten<{
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   }>,
    //   NewInput extends util.flatten<{
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }>
    // >(
    //   augmentation: Augmentation
    // ): ZodObject<
    //   extendShape<T, Augmentation>,
    //   UnknownKeys,
    //   Catchall,
    //   NewOutput,
    //   NewInput
    // > {
    //   return new ZodObject({
    //     ...this._def,
    //     shape: () => ({
    //       ...this._def.shape(),
    //       ...augmentation,
    //     }),
    //   }) as any;
    // }
    /**
     * @deprecated Use `.extend` instead
     *  */
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input4) {
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input4);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input4);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") {
      } else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          syncPairs.push({
            key,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new _ZodObject(__spreadValues(__spreadProps(__spreadValues({}, this._def), {
      unknownKeys: "strict"
    }), message !== void 0 ? {
      errorMap: (issue, ctx) => {
        var _a, _b, _c, _d;
        const defaultError = (_c = (_b = (_a = this._def).errorMap) == null ? void 0 : _b.call(_a, issue, ctx).message) != null ? _c : ctx.defaultError;
        if (issue.code === "unrecognized_keys")
          return {
            message: (_d = errorUtil.errToObj(message).message) != null ? _d : defaultError
          };
        return {
          message: defaultError
        };
      }
    } : {}));
  }
  strip() {
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      unknownKeys: "strip"
    }));
  }
  passthrough() {
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      unknownKeys: "passthrough"
    }));
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      shape: () => __spreadValues(__spreadValues({}, this._def.shape()), augmentation)
    }));
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => __spreadValues(__spreadValues({}, this._def.shape()), merging._def.shape()),
      typeName: "ZodObject" /* ZodObject */
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      catchall: index
    }));
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      shape: () => shape
    }));
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      shape: () => shape
    }));
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema == null ? void 0 : fieldSchema.optional();
      }
    });
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      shape: () => newShape
    }));
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      shape: () => newShape
    }));
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
__name(_ZodObject, "ZodObject");
_ZodObject.create = /* @__PURE__ */ __name((shape, params) => {
  return new _ZodObject(__spreadValues({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: "ZodObject" /* ZodObject */
  }, processCreateParams(params)));
}, "create");
_ZodObject.strictCreate = /* @__PURE__ */ __name((shape, params) => {
  return new _ZodObject(__spreadValues({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: "ZodObject" /* ZodObject */
  }, processCreateParams(params)));
}, "strictCreate");
_ZodObject.lazycreate = /* @__PURE__ */ __name((shape, params) => {
  return new _ZodObject(__spreadValues({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: "ZodObject" /* ZodObject */
  }, processCreateParams(params)));
}, "lazycreate");
var ZodObject = _ZodObject;

// src/z/types/pipeline/index.ts
var _ZodPipeline = class _ZodPipeline extends ZodType {
  _parse(input4) {
    const { status, ctx } = this._processInputParams(input4);
    if (ctx.common.async) {
      const handleAsync = /* @__PURE__ */ __name(async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }, "handleAsync");
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new _ZodPipeline({
      in: a,
      out: b,
      typeName: "ZodPipeline" /* ZodPipeline */
    });
  }
};
__name(_ZodPipeline, "ZodPipeline");
var ZodPipeline = _ZodPipeline;

// src/z/types/string/index.ts
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[a-z][a-z0-9]*$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var datetimeRegex = /* @__PURE__ */ __name((args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(
        `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`
      );
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
    }
  } else {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
    }
  }
}, "datetimeRegex");
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
__name(isValidIP, "isValidIP");
var _ZodString = class _ZodString extends ZodType {
  _parse(input4) {
    if (this._def.coerce) {
      input4.data = String(input4.data);
    }
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input4);
      addIssueToContext(
        ctx2,
        {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        }
        //
      );
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input4.data.length < check.value) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input4.data.length > check.value) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input4.data.length > check.value;
        const tooSmall = input4.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input4, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input4.data)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input4.data)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input4.data)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input4.data)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input4.data)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input4.data)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input4.data);
        } catch (e) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input4.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input4.data = input4.data.trim();
      } else if (check.kind === "includes") {
        if (!input4.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input4.data = input4.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input4.data = input4.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input4.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input4.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input4.data)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input4.data, check.version)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input4.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), __spreadValues({
      validation,
      code: ZodIssueCode.invalid_string
    }, errorUtil.errToObj(message)));
  }
  _addCheck(check) {
    return new _ZodString(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, check]
    }));
  }
  email(message) {
    return this._addCheck(__spreadValues({ kind: "email" }, errorUtil.errToObj(message)));
  }
  url(message) {
    return this._addCheck(__spreadValues({ kind: "url" }, errorUtil.errToObj(message)));
  }
  emoji(message) {
    return this._addCheck(__spreadValues({ kind: "emoji" }, errorUtil.errToObj(message)));
  }
  uuid(message) {
    return this._addCheck(__spreadValues({ kind: "uuid" }, errorUtil.errToObj(message)));
  }
  cuid(message) {
    return this._addCheck(__spreadValues({ kind: "cuid" }, errorUtil.errToObj(message)));
  }
  cuid2(message) {
    return this._addCheck(__spreadValues({ kind: "cuid2" }, errorUtil.errToObj(message)));
  }
  ulid(message) {
    return this._addCheck(__spreadValues({ kind: "ulid" }, errorUtil.errToObj(message)));
  }
  ip(options) {
    return this._addCheck(__spreadValues({ kind: "ip" }, errorUtil.errToObj(options)));
  }
  datetime(options) {
    var _a;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options
      });
    }
    return this._addCheck(__spreadValues({
      kind: "datetime",
      precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
      offset: (_a = options == null ? void 0 : options.offset) != null ? _a : false
    }, errorUtil.errToObj(options == null ? void 0 : options.message)));
  }
  regex(regex, message) {
    return this._addCheck(__spreadValues({
      kind: "regex",
      regex
    }, errorUtil.errToObj(message)));
  }
  includes(value, options) {
    return this._addCheck(__spreadValues({
      kind: "includes",
      value,
      position: options == null ? void 0 : options.position
    }, errorUtil.errToObj(options == null ? void 0 : options.message)));
  }
  startsWith(value, message) {
    return this._addCheck(__spreadValues({
      kind: "startsWith",
      value
    }, errorUtil.errToObj(message)));
  }
  endsWith(value, message) {
    return this._addCheck(__spreadValues({
      kind: "endsWith",
      value
    }, errorUtil.errToObj(message)));
  }
  min(minLength, message) {
    return this._addCheck(__spreadValues({
      kind: "min",
      value: minLength
    }, errorUtil.errToObj(message)));
  }
  max(maxLength, message) {
    return this._addCheck(__spreadValues({
      kind: "max",
      value: maxLength
    }, errorUtil.errToObj(message)));
  }
  length(len, message) {
    return this._addCheck(__spreadValues({
      kind: "length",
      value: len
    }, errorUtil.errToObj(message)));
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new _ZodString(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, { kind: "trim" }]
    }));
  }
  toLowerCase() {
    return new _ZodString(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    }));
  }
  toUpperCase() {
    return new _ZodString(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    }));
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
__name(_ZodString, "ZodString");
_ZodString.create = /* @__PURE__ */ __name((params) => {
  var _a;
  return new _ZodString(__spreadValues({
    checks: [],
    typeName: "ZodString" /* ZodString */,
    coerce: (_a = params == null ? void 0 : params.coerce) != null ? _a : false
  }, processCreateParams(params)));
}, "create");
var ZodString = _ZodString;

// src/z/types/record/index.ts
var _ZodRecord = class _ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input4) {
    const { status, ctx } = this._processInputParams(input4);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new _ZodRecord(__spreadValues({
        keyType: first,
        valueType: second,
        typeName: "ZodRecord" /* ZodRecord */
      }, processCreateParams(third)));
    }
    return new _ZodRecord(__spreadValues({
      keyType: ZodString.create(),
      valueType: first,
      typeName: "ZodRecord" /* ZodRecord */
    }, processCreateParams(second)));
  }
};
__name(_ZodRecord, "ZodRecord");
var ZodRecord = _ZodRecord;

// src/z/types/set/index.ts
var _ZodSet = class _ZodSet extends ZodType {
  _parse(input4) {
    const { status, ctx } = this._processInputParams(input4);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    __name(finalizeSet, "finalizeSet");
    const elements = [...ctx.data.values()].map(
      (item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i))
    );
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new _ZodSet(__spreadProps(__spreadValues({}, this._def), {
      minSize: { value: minSize, message: errorUtil.toString(message) }
    }));
  }
  max(maxSize, message) {
    return new _ZodSet(__spreadProps(__spreadValues({}, this._def), {
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    }));
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
__name(_ZodSet, "ZodSet");
_ZodSet.create = /* @__PURE__ */ __name((valueType, params) => {
  return new _ZodSet(__spreadValues({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: "ZodSet" /* ZodSet */
  }, processCreateParams(params)));
}, "create");
var ZodSet = _ZodSet;

// src/z/types/symbol/index.ts
var _ZodSymbol = class _ZodSymbol extends ZodType {
  _parse(input4) {
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input4);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input4.data);
  }
};
__name(_ZodSymbol, "ZodSymbol");
_ZodSymbol.create = /* @__PURE__ */ __name((params) => {
  return new _ZodSymbol(__spreadValues({
    typeName: "ZodSymbol" /* ZodSymbol */
  }, processCreateParams(params)));
}, "create");
var ZodSymbol = _ZodSymbol;

// src/z/types/union/index.ts
var _ZodUnion = class _ZodUnion extends ZodType {
  _parse(input4) {
    const { ctx } = this._processInputParams(input4);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    __name(handleResults, "handleResults");
    if (ctx.common.async) {
      return Promise.all(
        options.map(async (option) => {
          const childCtx = __spreadProps(__spreadValues({}, ctx), {
            common: __spreadProps(__spreadValues({}, ctx.common), {
              issues: []
            }),
            parent: null
          });
          return {
            result: await option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            }),
            ctx: childCtx
          };
        })
      ).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = __spreadProps(__spreadValues({}, ctx), {
          common: __spreadProps(__spreadValues({}, ctx.common), {
            issues: []
          }),
          parent: null
        });
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
__name(_ZodUnion, "ZodUnion");
_ZodUnion.create = /* @__PURE__ */ __name((types, params) => {
  return new _ZodUnion(__spreadValues({
    options: types,
    typeName: "ZodUnion" /* ZodUnion */
  }, processCreateParams(params)));
}, "create");
var ZodUnion = _ZodUnion;

// src/z/types/templateLiteral/index.ts
var _ZodTemplateLiteral = class _ZodTemplateLiteral extends ZodType {
  interpolated(type) {
    return this._addPart(type);
  }
  literal(literal) {
    return this._addPart(literal);
  }
  _parse(input4) {
    if (this._def.coerce) {
      input4.data = String(input4.data);
    }
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.string) {
      const ctx = this._getOrReturnCtx(input4);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (!new RegExp(this._def.regexString).test(input4.data)) {
      const ctx = this._getOrReturnCtx(input4);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_string,
        message: `does not match template literal with pattern /${this._def.regexString}/`,
        path: ctx.path,
        validation: "regex"
      });
      return INVALID;
    }
    return { status: "valid", value: input4.data };
  }
  _addPart(part) {
    const parts = [...this._def.parts, part];
    return new _ZodTemplateLiteral(__spreadProps(__spreadValues({}, this._def), {
      parts,
      regexString: this._appendToRegexString(this._def.regexString, part)
    }));
  }
  _appendToRegexString(regexString, part) {
    return `^${this._unwrapRegExp(regexString)}${this._transformPartToRegexString(part)}$`;
  }
  _transformPartToRegexString(part) {
    if (!(part instanceof ZodType)) {
      return this._escapeRegExp(part);
    }
    if (part instanceof ZodLiteral) {
      return this._escapeRegExp(part._def.value);
    }
    if (part instanceof ZodString) {
      return this._transformZodStringPartToRegexString(part);
    }
    if (part instanceof ZodEnum || part instanceof ZodNativeEnum) {
      const values = part instanceof ZodEnum ? part._def.values : util.getValidEnumValues(part._def.values);
      return `(${values.map(this._escapeRegExp).join("|")})`;
    }
    if (part instanceof ZodUnion) {
      return `(${part._def.options.map((option) => this._transformPartToRegexString(option)).join("|")})`;
    }
    if (part instanceof ZodNumber) {
      return this._transformZodNumberPartToRegexString(part);
    }
    if (part instanceof ZodOptional) {
      return `(${this._transformPartToRegexString(part.unwrap())})?`;
    }
    if (part instanceof _ZodTemplateLiteral) {
      return this._unwrapRegExp(part._def.regexString);
    }
    if (part instanceof ZodBigInt) {
      return "\\-?\\d+";
    }
    if (part instanceof ZodBoolean) {
      return "(true|false)";
    }
    if (part instanceof ZodNullable) {
      do {
        part = part.unwrap();
      } while (part instanceof ZodNullable);
      return `(${this._transformPartToRegexString(part)}|null)${part instanceof ZodOptional ? "?" : ""}`;
    }
    if (part instanceof ZodBranded) {
      return this._transformPartToRegexString(part.unwrap());
    }
    if (part instanceof ZodAny) {
      return ".*";
    }
    if (part instanceof ZodNull) {
      return "null";
    }
    if (part instanceof ZodUndefined) {
      return "undefined";
    }
    throw new ZodTemplateLiteralUnsupportedTypeError();
  }
  // FIXME: we don't support transformations, so `.trim()` is not supported.
  _transformZodStringPartToRegexString(part) {
    let maxLength = Infinity, minLength = 0, endsWith2 = "", startsWith = "";
    for (const ch of part._def.checks) {
      const regex = this._resolveRegexForStringCheck(ch);
      if (regex) {
        return this._unwrapRegExp(regex);
      }
      if (ch.kind === "endsWith") {
        endsWith2 = ch.value;
      } else if (ch.kind === "length") {
        minLength = maxLength = ch.value;
      } else if (ch.kind === "max") {
        maxLength = Math.max(0, Math.min(maxLength, ch.value));
      } else if (ch.kind === "min") {
        minLength = Math.max(minLength, ch.value);
      } else if (ch.kind === "startsWith") {
        startsWith = ch.value;
      } else {
        throw new ZodTemplateLiteralUnsupportedCheckError("ZodString" /* ZodString */, ch.kind);
      }
    }
    const constrainedMinLength = Math.max(0, minLength - startsWith.length - endsWith2.length);
    const constrainedMaxLength = Number.isFinite(maxLength) ? Math.max(0, maxLength - startsWith.length - endsWith2.length) : Infinity;
    if (constrainedMaxLength === 0 || constrainedMinLength > constrainedMaxLength) {
      return `${startsWith}${endsWith2}`;
    }
    return `${startsWith}.${this._resolveRegexWildcardLength(constrainedMinLength, constrainedMaxLength)}${endsWith2}`;
  }
  _resolveRegexForStringCheck(check) {
    var _a;
    return (_a = {
      [check.kind]: null,
      cuid: cuidRegex,
      cuid2: cuid2Regex,
      datetime: check.kind === "datetime" ? datetimeRegex(check) : null,
      email: emailRegex,
      ip: check.kind === "ip" ? {
        any: new RegExp(
          `^(${this._unwrapRegExp(ipv4Regex.source)})|(${this._unwrapRegExp(ipv6Regex.source)})$`
        ),
        v4: ipv4Regex,
        v6: ipv6Regex
      }[check.version || "any"] : null,
      regex: check.kind === "regex" ? check.regex : null,
      ulid: ulidRegex,
      uuid: uuidRegex
    }[check.kind]) != null ? _a : null;
  }
  _resolveRegexWildcardLength(minLength, maxLength) {
    if (minLength === maxLength) {
      return minLength === 1 ? "" : `{${minLength}}`;
    }
    if (maxLength !== Infinity) {
      return `{${minLength},${maxLength}}`;
    }
    if (minLength === 0) {
      return "*";
    }
    if (minLength === 1) {
      return "+";
    }
    return `{${minLength},}`;
  }
  // FIXME: we do not support exponent notation (e.g. 2e5) since it conflicts with `.int()`.
  _transformZodNumberPartToRegexString(part) {
    let canBeNegative = true, canBePositive = true, min = -Infinity, max = Infinity, canBeZero = true, isFinite2 = false, isInt = false, acc = "";
    for (const ch of part._def.checks) {
      if (ch.kind === "finite") {
        isFinite2 = true;
      } else if (ch.kind === "int") {
        isInt = true;
      } else if (ch.kind === "max") {
        max = Math.min(max, ch.value);
        if (ch.value <= 0) {
          canBePositive = false;
          if (ch.value === 0 && !ch.inclusive) {
            canBeZero = false;
          }
        }
      } else if (ch.kind === "min") {
        min = Math.max(min, ch.value);
        if (ch.value >= 0) {
          canBeNegative = false;
          if (ch.value === 0 && !ch.inclusive) {
            canBeZero = false;
          }
        }
      } else {
        throw new ZodTemplateLiteralUnsupportedCheckError("ZodNumber" /* ZodNumber */, ch.kind);
      }
    }
    if (Number.isFinite(min) && Number.isFinite(max)) {
      isFinite2 = true;
    }
    if (canBeNegative) {
      acc = `${acc}\\-`;
      if (canBePositive) {
        acc = `${acc}?`;
      }
    } else if (!canBePositive) {
      return "0+";
    }
    if (!isFinite2) {
      acc = `${acc}(Infinity|(`;
    }
    if (!canBeZero) {
      if (!isInt) {
        acc = `${acc}((\\d*[1-9]\\d*(\\.\\d+)?)|(\\d+\\.\\d*[1-9]\\d*))`;
      } else {
        acc = `${acc}\\d*[1-9]\\d*`;
      }
    } else if (isInt) {
      acc = `${acc}\\d+`;
    } else {
      acc = `${acc}\\d+(\\.\\d+)?`;
    }
    if (!isFinite2) {
      acc = `${acc}))`;
    }
    return acc;
  }
  _unwrapRegExp(regex) {
    const flags = typeof regex === "string" ? "" : regex.flags;
    const source = typeof regex === "string" ? regex : regex.source;
    if (flags.includes("i")) {
      return this._unwrapRegExp(this._makeRegexStringCaseInsensitive(source));
    }
    return source.replace(/(^\^)|(\$$)/g, "");
  }
  _makeRegexStringCaseInsensitive(regexString) {
    const isAlphabetic = /* @__PURE__ */ __name((char) => char.match(/[a-z]/i) != null, "isAlphabetic");
    let caseInsensitive = "";
    let inCharacterSet = false;
    for (let i = 0; i < regexString.length; i++) {
      const char = regexString.charAt(i);
      const nextChar = regexString.charAt(i + 1);
      if (char === "\\") {
        caseInsensitive += `${char}${nextChar}`;
        i++;
        continue;
      }
      if (char === "[") {
        inCharacterSet = true;
      } else if (inCharacterSet && char === "]") {
        inCharacterSet = false;
      }
      if (!isAlphabetic(char)) {
        caseInsensitive += char;
        continue;
      }
      if (!inCharacterSet) {
        caseInsensitive += `[${char.toLowerCase()}${char.toUpperCase()}]`;
        continue;
      }
      const charAfterNext = regexString.charAt(i + 2);
      if (nextChar !== "-" || !isAlphabetic(charAfterNext)) {
        caseInsensitive += `${char.toLowerCase()}${char.toUpperCase()}`;
        continue;
      }
      caseInsensitive += `${char.toLowerCase()}-${charAfterNext.toLowerCase()}${char.toUpperCase()}-${charAfterNext.toUpperCase()}`;
      i += 2;
    }
    return caseInsensitive;
  }
  _escapeRegExp(str) {
    if (typeof str !== "string") {
      str = `${str}`;
    }
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
};
__name(_ZodTemplateLiteral, "ZodTemplateLiteral");
_ZodTemplateLiteral.create = /* @__PURE__ */ __name((params) => {
  var _a;
  return new _ZodTemplateLiteral(__spreadProps(__spreadValues({}, processCreateParams(params)), {
    coerce: (_a = params == null ? void 0 : params.coerce) != null ? _a : false,
    parts: [],
    regexString: "^$",
    typeName: "ZodTemplateLiteral" /* ZodTemplateLiteral */
  }));
}, "create");
var ZodTemplateLiteral = _ZodTemplateLiteral;

// src/z/types/void/index.ts
var _ZodVoid = class _ZodVoid extends ZodType {
  _parse(input4) {
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input4);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input4.data);
  }
};
__name(_ZodVoid, "ZodVoid");
_ZodVoid.create = /* @__PURE__ */ __name((params) => {
  return new _ZodVoid(__spreadValues({
    typeName: "ZodVoid" /* ZodVoid */
  }, processCreateParams(params)));
}, "create");
var ZodVoid = _ZodVoid;

// src/z/z.ts
var late = {
  object: ZodObject.lazycreate
};
var instanceOfType = /* @__PURE__ */ __name((cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params), "instanceOfType");
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var templateLiteralType = ZodTemplateLiteral.create;
var ostring = /* @__PURE__ */ __name(() => stringType().optional(), "ostring");
var onumber = /* @__PURE__ */ __name(() => numberType().optional(), "onumber");
var oboolean = /* @__PURE__ */ __name(() => booleanType().optional(), "oboolean");
var fromJsonSchema = ZodType.fromJsonSchema;
var fromObject = ZodType.fromObject;
var coerce = {
  string: (arg) => ZodString.create(__spreadProps(__spreadValues({}, arg), { coerce: true })),
  number: (arg) => ZodNumber.create(__spreadProps(__spreadValues({}, arg), { coerce: true })),
  boolean: (arg) => ZodBoolean.create(__spreadProps(__spreadValues({}, arg), {
    coerce: true
  })),
  bigint: (arg) => ZodBigInt.create(__spreadProps(__spreadValues({}, arg), { coerce: true })),
  date: (arg) => ZodDate.create(__spreadProps(__spreadValues({}, arg), { coerce: true })),
  templateLiteral: (arg) => ZodTemplateLiteral.create(__spreadProps(__spreadValues({}, arg), {
    coerce: true
  }))
};
var NEVER = INVALID;

// src/transforms/json-schema-to-zui/index.ts
var jsonSchemaToZodStr = /* @__PURE__ */ __name((schema) => {
  return parseSchema2(schema, {
    seen: /* @__PURE__ */ new Map(),
    path: []
  });
}, "jsonSchemaToZodStr");
var jsonSchemaToZod = /* @__PURE__ */ __name((schema) => {
  let code = jsonSchemaToZodStr(schema);
  code = code.replaceAll("errors: z.ZodError[]", "errors");
  return new Function("z", `return ${code}`)(z_exports);
}, "jsonSchemaToZod");
var applyZuiPropsRecursively = /* @__PURE__ */ __name((zodField, jsonSchemaField) => {
  var _a, _b;
  if (jsonSchemaField[zuiKey] && zodField._def) {
    zodField._def[zuiKey] = jsonSchemaField[zuiKey];
  }
  if (((_a = zodField._def) == null ? void 0 : _a.typeName) === "ZodObject" && jsonSchemaField.type === "object" && jsonSchemaField.properties) {
    Object.entries(jsonSchemaField.properties).forEach(([key, nestedField]) => {
      const shape = typeof zodField._def.shape === "function" ? zodField._def.shape() : zodField._def.shape;
      if (shape[key]) {
        applyZuiPropsRecursively(shape[key], nestedField);
      }
    });
  }
  if (((_b = zodField._def) == null ? void 0 : _b.typeName) === "ZodRecord" && jsonSchemaField.type === "object" && jsonSchemaField.additionalProperties) {
    applyZuiPropsRecursively(zodField._def.valueType, jsonSchemaField.additionalProperties);
  }
  if (jsonSchemaField.type === "array" && jsonSchemaField.items) {
    const items = jsonSchemaField.items;
    if (typeof items === "object" && !Array.isArray(items)) {
      const arrayShape = zodField._def.type;
      if (arrayShape) {
        applyZuiPropsRecursively(arrayShape, items);
      }
    } else if (Array.isArray(items)) {
      items.forEach((item, index) => {
        if (zodField._def.type[index]) {
          applyZuiPropsRecursively(zodField._def.type[index], item);
        }
      });
    }
  }
}, "applyZuiPropsRecursively");
var jsonSchemaToZui = /* @__PURE__ */ __name((schema) => {
  const zodSchema = jsonSchemaToZod(schema);
  applyZuiPropsRecursively(zodSchema, schema);
  return zodSchema;
}, "jsonSchemaToZui");

// src/ui/index.tsx
import React2, { useMemo as useMemo2 } from "react";

// src/ui/providers/FormDataProvider.tsx
import { createContext, useContext, useMemo } from "react";
import React from "react";
var FormDataContext = createContext({
  formData: void 0,
  formSchema: void 0,
  setFormData: () => {
    throw new Error("Must be within a FormDataProvider");
  },
  disableValidation: false
});
var useFormData = /* @__PURE__ */ __name(() => {
  const context = useContext(FormDataContext);
  if (context === void 0) {
    throw new Error("useFormData must be used within a FormDataProvider");
  }
  const validation = useMemo(() => {
    if (context.disableValidation) {
      return { formValid: null, formErrors: null };
    }
    if (!context.formSchema) {
      return { formValid: null, formErrors: null };
    }
    const validation2 = jsonSchemaToZui(context.formSchema).safeParse(context.formData);
    if (!validation2.success) {
      return {
        formValid: false,
        formErrors: validation2.error.issues
      };
    }
    return {
      formValid: true,
      formErrors: []
    };
  }, [context.formData]);
  const handlePropertyChange = /* @__PURE__ */ __name((path, data) => {
    context.setFormData(setObjectPath(context.formData, path, data));
  }, "handlePropertyChange");
  const addArrayItem = /* @__PURE__ */ __name((path, data) => {
    const currentData = getPathData(context.formData, path.split(".")) || [];
    context.setFormData(setObjectPath(context.formData, path, [...currentData, data]));
  }, "addArrayItem");
  const removeArrayItem = /* @__PURE__ */ __name((path, index) => {
    const currentData = getPathData(context.formData, path.split("."));
    currentData.splice(index, 1);
    context.setFormData(setObjectPath(context.formData, path, currentData));
  }, "removeArrayItem");
  return __spreadValues(__spreadProps(__spreadValues({}, context), { handlePropertyChange, addArrayItem, removeArrayItem }), validation);
}, "useFormData");
function setObjectPath(obj, path, data) {
  const pathArray = path.split(".");
  const pathArrayLength = pathArray.length;
  pathArray.reduce((current, key, index) => {
    if (index === pathArrayLength - 1) {
      current[key] = data;
    } else {
      if (!current[key]) {
        current[key] = isNaN(Number(key)) ? {} : [];
      }
    }
    return current[key];
  }, obj != null ? obj : {});
  return __spreadValues({}, obj);
}
__name(setObjectPath, "setObjectPath");
var getDefaultItemData = /* @__PURE__ */ __name((schema) => {
  if (schema.type === "object") {
    return {};
  }
  if (schema.type === "array") {
    return [];
  }
  if (schema.type === "string") {
    return "";
  }
  if (schema.type === "number") {
    return 0;
  }
  if (schema.type === "boolean") {
    return false;
  }
  return null;
}, "getDefaultItemData");
var FormDataProvider = /* @__PURE__ */ __name(({
  children,
  setFormData,
  formData,
  formSchema,
  disableValidation
}) => {
  return /* @__PURE__ */ React.createElement(FormDataContext.Provider, { value: { formData, setFormData, formSchema, disableValidation } }, children);
}, "FormDataProvider");
function getPathData(object, path) {
  return path.reduce((prev, curr) => {
    return prev ? prev[curr] : null;
  }, object);
}
__name(getPathData, "getPathData");

// src/ui/titleutils.ts
function formatTitle(title, separator) {
  if (!separator)
    separator = new RegExp("/s|-|_| ", "g");
  return decamelize(title).split(separator).map(capitalize).map(handleSpecialWords).reduce(combine);
}
__name(formatTitle, "formatTitle");
function capitalize(word) {
  return word.charAt(0).toUpperCase() + word.substring(1);
}
__name(capitalize, "capitalize");
function combine(acc, text) {
  return `${acc} ${text}`;
}
__name(combine, "combine");
function decamelize(text) {
  return text.replace(/([a-z\d])([A-Z])/g, "$1_$2").replace(/([A-Z]+)([A-Z][a-z\d]+)/g, "$1_$2").toLowerCase();
}
__name(decamelize, "decamelize");
function handleSpecialWords(text, index, words) {
  const lowercaseStr = text.toLowerCase();
  const uppercaseStr = text.toUpperCase();
  for (const special of specialCase) {
    if (special.toLowerCase() === lowercaseStr)
      return special;
  }
  if (acronyms.includes(uppercaseStr))
    return uppercaseStr;
  if (index === 0)
    return text;
  if (index === words.length - 1)
    return text;
  if (text.length >= 4)
    return text;
  if (prepositions.includes(lowercaseStr))
    return lowercaseStr;
  if (conjunctions.includes(lowercaseStr))
    return lowercaseStr;
  if (articles.includes(lowercaseStr))
    return lowercaseStr;
  return text;
}
__name(handleSpecialWords, "handleSpecialWords");
var acronyms = [
  "2D",
  "3D",
  "4WD",
  "A2O",
  "API",
  "BIOS",
  "CCTV",
  "CC",
  "CCV",
  "CD",
  "CD-ROM",
  "COBOL",
  "CIA",
  "CMS",
  "CSS",
  "CSV",
  "CV",
  "DIY",
  "DVD",
  "DB",
  "DNA",
  "E3",
  "EIN",
  "ESPN",
  "FAQ",
  "FAQs",
  "FTP",
  "FPS",
  "FORTRAN",
  "FBI",
  "HTML",
  "HTTP",
  "ID",
  "IP",
  "ISO",
  "JS",
  "JSON",
  "LASER",
  "M2A",
  "M2M",
  "M2MM",
  "M2O",
  "MMORPG",
  "NAFTA",
  "NASA",
  "NDA",
  "O2M",
  "PDF",
  "PHP",
  "POP",
  "RAM",
  "RNGR",
  "ROM",
  "RPG",
  "RTFM",
  "RTS",
  "SCUBA",
  "SITCOM",
  "SKU",
  "SMTP",
  "SQL",
  "SSN",
  "SWAT",
  "TBS",
  "TTL",
  "TV",
  "TNA",
  "UI",
  "URL",
  "USB",
  "UWP",
  "VIP",
  "W3C",
  "WYSIWYG",
  "WWW",
  "WWE",
  "WWF"
];
var articles = ["a", "an", "the"];
var conjunctions = [
  "and",
  "that",
  "but",
  "or",
  "as",
  "if",
  "when",
  "than",
  "because",
  "while",
  "where",
  "after",
  "so",
  "though",
  "since",
  "until",
  "whether",
  "before",
  "although",
  "nor",
  "like",
  "once",
  "unless",
  "now",
  "except"
];
var prepositions = [
  "about",
  "above",
  "across",
  "after",
  "against",
  "along",
  "among",
  "around",
  "at",
  "because of",
  "before",
  "behind",
  "below",
  "beneath",
  "beside",
  "besides",
  "between",
  "beyond",
  "but",
  "by",
  "concerning",
  "despite",
  "down",
  "during",
  "except",
  "excepting",
  "for",
  "from",
  "in",
  "in front of",
  "inside",
  "in spite of",
  "instead of",
  "into",
  "like",
  "near",
  "of",
  "off",
  "on",
  "onto",
  "out",
  "outside",
  "over",
  "past",
  "regarding",
  "since",
  "through",
  "throughout",
  "to",
  "toward",
  "under",
  "underneath",
  "until",
  "up",
  "upon",
  "up to",
  "with",
  "within",
  "without",
  "with regard to",
  "with respect to"
];
var specialCase = [
  "2FA",
  "3D",
  "4K",
  "5K",
  "8K",
  "AGI",
  "BI",
  "ChatGPT",
  "CTA",
  "DateTime",
  "GitHub",
  "GPT",
  "HD",
  "IBMid",
  "ID",
  "IDs",
  "iMac",
  "IMAX",
  "iOS",
  "IP",
  "iPad",
  "iPhone",
  "iPod",
  "LDAP",
  "LinkedIn",
  "LLM",
  "M2M",
  "M2O",
  "macOS",
  "McDonalds",
  "ML",
  "MySQL",
  "NLG",
  "NLP",
  "NLU",
  "O2M",
  "OpenAI",
  "PDFs",
  "PEFT",
  "pH",
  "PostgreSQL",
  "SEO",
  "TTS",
  "UHD",
  "UUID",
  "XSS",
  "YouTube"
];

// src/ui/index.tsx
var resolveComponent = /* @__PURE__ */ __name((components, fieldSchema) => {
  var _a, _b, _c;
  const type = fieldSchema.type;
  const uiDefinition = ((_a = fieldSchema[zuiKey]) == null ? void 0 : _a.displayAs) || null;
  if (!uiDefinition || !Array.isArray(uiDefinition) || uiDefinition.length < 2) {
    const defaultComponent = (_b = components == null ? void 0 : components[type]) == null ? void 0 : _b.default;
    if (!defaultComponent) {
      return null;
    }
    return {
      Component: defaultComponent,
      type,
      id: "default",
      params: {}
    };
  }
  const componentID = uiDefinition[0];
  const Component = ((_c = components == null ? void 0 : components[type]) == null ? void 0 : _c[componentID]) || null;
  if (!Component) {
    console.warn(`Component ${type}.${componentID} not found`);
    return null;
  }
  const params = uiDefinition[1] || {};
  return {
    Component,
    type,
    id: componentID,
    params
  };
}, "resolveComponent");
var ZuiForm = /* @__PURE__ */ __name(({
  schema,
  components,
  onChange,
  value,
  disableValidation
}) => {
  return /* @__PURE__ */ React2.createElement(
    FormDataProvider,
    {
      formData: value,
      setFormData: onChange,
      formSchema: schema,
      disableValidation: disableValidation || false
    },
    /* @__PURE__ */ React2.createElement(
      FormElementRenderer,
      {
        components,
        fieldSchema: schema,
        path: [],
        required: true,
        isArrayChild: false
      }
    )
  );
}, "ZuiForm");
var FormElementRenderer = /* @__PURE__ */ __name((_a) => {
  var _b = _a, { components, fieldSchema, path, required } = _b, childProps = __objRest(_b, ["components", "fieldSchema", "path", "required"]);
  var _a2, _b2, _c, _d, _e;
  const { formData, handlePropertyChange, addArrayItem, removeArrayItem, formErrors, formValid } = useFormData();
  const data = useMemo2(() => getPathData(formData, path), [formData, path]);
  const componentMeta = useMemo2(() => resolveComponent(components, fieldSchema), [fieldSchema, components]);
  if (!componentMeta) {
    return null;
  }
  if (((_a2 = fieldSchema[zuiKey]) == null ? void 0 : _a2.hidden) === true) {
    return null;
  }
  const { Component: _component, type } = componentMeta;
  const pathString = path.length > 0 ? path.join(".") : "root";
  const baseProps = {
    type,
    componentID: componentMeta.id,
    scope: pathString,
    context: {
      path: pathString,
      readonly: false,
      formData,
      formErrors,
      formValid,
      updateForm: handlePropertyChange
    },
    enabled: ((_b2 = fieldSchema[zuiKey]) == null ? void 0 : _b2.disabled) !== true,
    onChange: (data2) => handlePropertyChange(pathString, data2),
    errors: (formErrors == null ? void 0 : formErrors.filter((e) => e.path.join(".") === pathString)) || [],
    label: ((_c = fieldSchema[zuiKey]) == null ? void 0 : _c.title) || formatTitle(((_d = path[path.length - 1]) == null ? void 0 : _d.toString()) || ""),
    params: componentMeta.params,
    schema: fieldSchema,
    zuiProps: fieldSchema[zuiKey]
  };
  if (fieldSchema.type === "array" && type === "array") {
    const Component2 = _component;
    const schema = baseProps.schema;
    const props2 = __spreadValues(__spreadProps(__spreadValues({}, baseProps), {
      type,
      schema,
      data: Array.isArray(data) ? data : [],
      addItem: (data2 = void 0) => addArrayItem(baseProps.context.path, typeof data2 === "undefined" ? getDefaultItemData(schema.items) : data2),
      removeItem: (index) => removeArrayItem(baseProps.context.path, index)
    }), childProps);
    return /* @__PURE__ */ React2.createElement(Component2, __spreadProps(__spreadValues({ key: baseProps.scope }, props2), { isArrayChild: props2.isArrayChild }), ((_e = props2.data) == null ? void 0 : _e.map((_, index) => {
      const childPath = [...path, index.toString()];
      return /* @__PURE__ */ React2.createElement(
        FormElementRenderer,
        {
          key: childPath.join("."),
          components,
          fieldSchema: fieldSchema.items,
          path: childPath,
          required,
          isArrayChild: true,
          index,
          removeSelf: () => removeArrayItem(baseProps.context.path, index)
        }
      );
    })) || []);
  }
  if (fieldSchema.type === "object" && type === "object") {
    const Component2 = _component;
    const props2 = __spreadValues(__spreadProps(__spreadValues({}, baseProps), {
      type,
      schema: baseProps.schema,
      data: data || {}
    }), childProps);
    return /* @__PURE__ */ React2.createElement(Component2, __spreadProps(__spreadValues({ key: baseProps.scope }, props2), { isArrayChild: props2.isArrayChild }), Object.entries(fieldSchema.properties).map(([fieldName, childSchema]) => {
      var _a3;
      const childPath = [...path, fieldName];
      return /* @__PURE__ */ React2.createElement(
        FormElementRenderer,
        {
          key: childPath.join("."),
          components,
          fieldSchema: childSchema,
          path: childPath,
          required: ((_a3 = fieldSchema.required) == null ? void 0 : _a3.includes(fieldName)) || false,
          isArrayChild: false
        }
      );
    }));
  }
  const Component = _component;
  const props = __spreadValues(__spreadProps(__spreadValues({}, baseProps), {
    type,
    schema: baseProps.schema,
    config: {},
    required,
    data,
    description: fieldSchema.description
  }), childProps);
  return /* @__PURE__ */ React2.createElement(Component, __spreadValues({}, props));
}, "FormElementRenderer");

// src/index.ts
var transforms = {
  jsonSchemaToZui,
  zuiToJsonSchema,
  objectToZui,
  zuiToTypescriptTypings: toTypescriptTypings
};
export {
  BRAND,
  DIRTY,
  EMPTY_PATH,
  INVALID,
  NEVER,
  OK,
  ParseInputLazyPath,
  ParseStatus,
  ZodType as Schema,
  ZodAny,
  ZodArray,
  ZodBigInt,
  ZodBoolean,
  ZodBranded,
  ZodCatch,
  ZodDate,
  ZodDefault,
  ZodDiscriminatedUnion,
  ZodEffects,
  ZodEnum,
  ZodError,
  ZodFirstPartyTypeKind,
  ZodFunction,
  ZodIntersection,
  ZodIssueCode,
  ZodLazy,
  ZodLiteral,
  ZodMap,
  ZodNaN,
  ZodNativeEnum,
  ZodNever,
  ZodNull,
  ZodNullable,
  ZodNumber,
  ZodObject,
  ZodOptional,
  ZodParsedType,
  ZodPipeline,
  ZodPromise,
  ZodReadonly,
  ZodRecord,
  ZodType as ZodSchema,
  ZodSet,
  ZodString,
  ZodSymbol,
  ZodTemplateLiteral,
  ZodTemplateLiteralUnsupportedCheckError,
  ZodTemplateLiteralUnsupportedTypeError,
  ZodEffects as ZodTransformer,
  ZodTuple,
  ZodType,
  ZodUndefined,
  ZodUnion,
  ZodUnknown,
  ZodVoid,
  ZuiForm,
  addIssueToContext,
  anyType as any,
  arrayType as array,
  bigIntType as bigint,
  booleanType as boolean,
  coerce,
  createZodEnum,
  cuid2Regex,
  cuidRegex,
  custom,
  dateType as date,
  datetimeRegex,
  en_default as defaultErrorMap,
  discriminatedUnionType as discriminatedUnion,
  effectsType as effect,
  emailRegex,
  enumType as enum,
  errorUtil,
  fromJsonSchema,
  fromObject,
  functionType as function,
  getErrorMap,
  getParsedType,
  instanceOfType as instanceof,
  intersectionType as intersection,
  ipv4Regex,
  ipv6Regex,
  isAborted,
  isAsync,
  isDirty,
  isValid,
  jsonSchemaToZui,
  late,
  lazyType as lazy,
  literalType as literal,
  makeIssue,
  mapType as map,
  nanType as nan,
  nativeEnumType as nativeEnum,
  neverType as never,
  nullType as null,
  nullableType as nullable,
  numberType as number,
  objectType as object,
  objectToZui,
  objectUtil,
  oboolean,
  onumber,
  optionalType as optional,
  ostring,
  pipelineType as pipeline,
  preprocessType as preprocess,
  processCreateParams,
  promiseType as promise,
  quotelessJson,
  recordType as record,
  setType as set,
  setErrorMap,
  strictObjectType as strictObject,
  stringType as string,
  symbolType as symbol,
  templateLiteralType as templateLiteral,
  effectsType as transformer,
  transforms,
  tupleType as tuple,
  ulidRegex,
  undefinedType as undefined,
  unionType as union,
  unknownType as unknown,
  util,
  uuidRegex,
  voidType as void,
  z_exports as z,
  zuiToJsonSchema
};
//# sourceMappingURL=index.js.map